<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <title>Deceptionist - Not All Exits Are Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden;
            min-height: 100vh;
            color: #fff;
        }

        .mobile-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Mobile Navbar */
        .mobile-navbar {
            display: flex;
            width: 100%;
            background: linear-gradient(135deg, #f9d423 0%, #ff4e50 100%);
            color: #1a202c;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 60px;
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .home-icon {
            font-size: 20px;
            cursor: pointer;
        }

        .mobile-navbar-title {
            font-weight: 800;
            font-size: 18px;
            letter-spacing: 0.5px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .hamburger-menu {
            font-size: 20px;
            cursor: pointer;
            margin-left: auto;
        }

        /* Hamburger Menu Dropdown */
        .hamburger-dropdown {
            position: fixed;
            top: 60px;
            right: 16px;
            background: linear-gradient(135deg, #1a202c, #2d3748);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 1001;
            min-width: 150px;
        }

        .hamburger-dropdown.show {
            display: flex;
        }

        .hamburger-item-1 {
            padding: 10px 15px;
            background: #D1DF3B;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: 500;
        }

        .hamburger-item-2 {
            padding: 10px 15px;
            background: #3BDE67;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: 500;
        }

        .hamburger-item-3 {
            padding: 10px 15px;
            background: #DF3B3B;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: 500;
        }

        /* Main Content Area */
        .mobile-content {
            flex: 1;
            padding: 80px 20px 20px 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        /* Turn Info Section */
        .turn-info-section {
            display: flex;
            width: 100%;
            gap: 10px;
            margin-bottom: 10px;
        }

        .turn-info-left,
        .turn-info-right {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #current-turn-mobile {
            font-size: 16px;
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 5px;
        }

        .turn-label {
            font-size: 12px;
            color: #a0aec0;
        }

        #you-are-mobile {
            font-size: 14px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            color: #fff;
            display: inline-block;
            margin-bottom: 5px;
        }

        /* Board Section */
        .board-section {
            width: 100%;
            margin: 10px 0;
        }

        .outer-box {
            position: relative;
            width: 100%;
            /* Reduced height so board is shorter on phones */
            height: 36vh;
            background-image: url('board_bg.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            border: 4px solid #2d3748;
            padding: 0.5%;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: auto;
            overflow: visible;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            grid-template-rows: repeat(14, 1fr);
            gap: 0.3vw;
            width: 100%;
            height: 100%;
            overflow: visible;
            position: relative;
        }

        .grid-item {
            background: transparent;
            border-radius: 3px;
            border: 2px solid rgba(0, 0, 0, 0.6);
            width: 100%;
            height: 100%;
            position: relative;
            overflow: visible;
            cursor: pointer;
        }

        .location-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            /* nudge slightly downward on mobile so top entry icons sit lower */
            transform: translate(-50%, -40%);
            width: 16px;
            height: 16px;
            z-index: 1;
        }

        .goti {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            z-index: 2;
            transition: all 0.3s ease;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 255, 255, 0.2);
        }

        /* Controls Section */
        .controls-section {
            display: flex;
            width: 100%;
            gap: 15px;
            margin-top: 10px;
        }

        .dice-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .wall-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #dice-face-mobile {
            display: inline-block;
        }

        .cube {
            width: 60px;
            height: 60px;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(0deg) rotateY(0deg);
            transition: transform 2s cubic-bezier(0.25, 1.5, 0.5, 1);
            cursor: pointer;
            margin: 0 auto;
        }

        .face {
            position: absolute;
            width: 60px;
            height: 60px;
            background: white;
            border: 1px solid #2d3748;
            border-radius: 12px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            box-sizing: border-box;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #2d3748;
            border-radius: 50%;
            justify-self: center;
            align-self: center;
        }

        .front {
            transform: rotateY(0deg) translateZ(30px);
        }

        .back {
            transform: rotateY(180deg) translateZ(30px);
        }

        .right {
            transform: rotateY(90deg) translateZ(30px);
        }

        .left {
            transform: rotateY(-90deg) translateZ(30px);
        }

        .top {
            transform: rotateX(90deg) translateZ(30px);
        }

        .bottom {
            transform: rotateX(-90deg) translateZ(30px);
        }

        #dice-result-mobile {
            font-size: 16px;
            font-weight: bold;
            color: #e2e8f0;
            text-align: center;
        }

        #walls-left-mobile {
            font-size: 16px;
            font-weight: bold;
            color: #e2e8f0;
            text-align: center;
        }

        #roll-btn-mobile {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #D2E03C, #D2E03C);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            width: 100%;
        }

        /* hide the original roll button (we'll use the dice icon instead) */
        #roll-btn-mobile {
            display: none !important;
        }

        #place-wall-btn-mobile {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #FF9800, #e68900);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        #roll-btn-mobile:hover,
        #place-wall-btn-mobile:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        #roll-btn-mobile:disabled,
        #place-wall-btn-mobile:disabled {
            background: #718096;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Make place-wall button visibly faded when disabled */
        #place-wall-btn-mobile:disabled {
            opacity: 0.5;
        }

        /* dice icon button to replace roll btn on mobile */
        .dice-icon-btn {
            width: 54px;
            height: 54px;
            border-radius: 10px;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
            cursor: pointer;
            transition: transform 200ms ease, box-shadow 200ms ease, opacity 200ms ease;
        }

        .dice-icon-btn.disabled {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
            box-shadow: none;
        }

        .dice-icon-btn svg {
            width: 36px;
            height: 36px;
        }

        /* subtle bounce animation */
        @keyframes dicePulse {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-6px);
            }

            100% {
                transform: translateY(0);
            }
        }

        .dice-icon-btn.animate {
            animation: dicePulse 1.4s ease-in-out infinite;
        }

        /* Wall Stacks */
        #wall-stacks {
            position: absolute;
            bottom: 0%;
            right: 2%;
            display: flex;
            gap: 1vw;
            justify-content: center;
            align-items: flex-end;
            z-index: 5;
        }

        .wall-block {
            width: clamp(18px, 4.6vw, 34px);
            height: clamp(8px, 1.2vw, 12px);
            border: clamp(1px, 0.3vw, 2px) solid rgba(0, 0, 0, 0.7);
        }

        .wall-stack-column {
            display: grid;
            grid-template-rows: repeat(3, clamp(6px, 1.1vw, 12px));
            row-gap: clamp(4px, 0.6vw, 8px);
            align-items: end;
        }

        .wall-overlay {
            position: absolute;
            inset: 2px;
            pointer-events: none;
            animation: wallPlacement 1.5s ease-out;
        }

        @keyframes wallPlacement {
            0% {
                transform: scale(3.5);
                opacity: 0;
            }

            50% {
                transform: scale(2.5);
                opacity: 0.12;
            }

            70% {
                transform: scale(1.7);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Modal Styles */
        .info-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .info-modal {
            background: #000;
            color: #fff;
            padding: 20px 22px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            max-width: 420px;
            width: 92%;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .info-modal p {
            margin: 10px 0 18px;
            font-size: 16px;
            line-height: 1.3;
        }

        .info-modal .ok-btn {
            padding: 10px 18px;
            background: #fff;
            color: #000;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }

        /* Settings Modal */
        #settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .settings-card {
            background: linear-gradient(135deg, #1a202c, #2d3748);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-title {
            font-size: 24px;
            margin-bottom: 25px;
            color: #fff;
            font-weight: 600;
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            transition: all 0.3s;
        }

        .settings-option:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .option-label {
            font-size: 18px;
            color: #fff;
            font-weight: 500;
        }

        .sound-toggle {
            width: 60px;
            height: 30px;
            background: #718096;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .sound-toggle.active {
            background: #4CAF50;
        }

        .sound-toggle::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .sound-toggle.active::after {
            transform: translateX(30px);
        }

        .sound-icon {
            font-size: 20px;
            margin-right: 10px;
        }

        .close-settings {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            width: 100%;
        }

        .close-settings:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        /* Color Selection */
        #color-selection {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .selection-card {
            background: linear-gradient(135deg, #1a202c, #2d3748);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .selection-title {
            font-size: 28px;
            margin-bottom: 30px;
            color: #fff;
            font-weight: 600;
        }

        .color-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .color-option {
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            font-size: 18px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .color-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.4);
        }

        .color-option.selected {
            transform: scale(1.05);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.8), 0 0 0 6px currentColor;
        }

        #start-game-btn {
            padding: 14px 40px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
        }

        #start-game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(76, 175, 80, 0.4);
        }

        /* Win Overlay */
        #win-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .win-card {
            background: linear-gradient(135deg, #1a202c, #2d3748);
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            width: 90%;
        }

        #win-text {
            font-size: 26px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }

        #reset-btn {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        #reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        /* Entry Arrows */
        .entry-arrow {
            position: absolute;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1200;
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.6));
        }

        .entry-arrow svg {
            width: 100%;
            height: 100%;
        }

        /* Highlight styles */
        .highlighted-forward {
            background-color: rgba(0, 255, 0, 0.5) !important;
            border: 3px solid green !important;
        }

        .highlighted-backward {
            background-color: rgba(255, 0, 0, 0.5) !important;
            border: 3px solid red !important;
        }

        .glow {
            box-shadow: 0 0 18px 6px rgba(255, 255, 255, 0.08), 0 0 40px 8px rgba(255, 255, 0, 0.18) !important;
            animation: pulseGlow 1.6s infinite;
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.04), 0 0 20px rgba(255, 255, 0, 0.08);
            }

            50% {
                box-shadow: 0 0 22px rgba(255, 255, 255, 0.06), 0 0 48px rgba(255, 255, 0, 0.22);
            }

            100% {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.04), 0 0 20px rgba(255, 255, 0, 0.08);
            }
        }
    </style>
</head>

<body>
    <div class="mobile-container">
        <!-- Mobile Navbar -->
        <div class="mobile-navbar">
            <div class="nav-left">
                <div class="home-icon"><i class="fa-solid fa-house"></i></div>
            </div>
            <div class="mobile-navbar-title">Deceptionist</div>
            <div class="hamburger-menu">â˜°</div>

            <!-- Hamburger Dropdown Menu -->
            <div class="hamburger-dropdown" id="hamburger-dropdown">
                <div class="hamburger-item-1" id="view-rules-btn">See Rules</div>
                <div class="hamburger-item-2" id="settings-btn">Settings</div>
                <div class="hamburger-item-3" id="reset-game-btn">Reset Game</div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="mobile-content">
            <!-- Turn Info Section -->
            <div class="turn-info-section">
                <div class="turn-info-left">
                    <div id="current-turn-mobile">This Turn: Yellow</div>
                    <div class="turn-label">This Turn</div>
                </div>
                <div class="turn-info-right">
                    <div id="you-are-mobile">You are: <strong id="you-color-mobile">Yellow</strong></div>
                    <div class="turn-label">Your Color</div>
                </div>
            </div>

            <!-- Board Section -->
            <div class="board-section">
                <div class="outer-box">
                    <div class="grid-container" id="grid-container">
                        <!-- Grid will be generated by JavaScript -->
                        <div id="wall-stacks"></div>
                    </div>
                </div>
            </div>

            <!-- Controls Section -->
            <div class="controls-section">
                <div class="dice-section">
                    <div id="dice-face-mobile">
                        <div class="cube" id="dice-mobile">
                            <!-- 1 -->
                            <div class="face front">
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                            </div>
                            <!-- 6 -->
                            <div class="face back">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:1; grid-row:2;"></div>
                                <div class="dot" style="grid-column:3; grid-row:2;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 3 -->
                            <div class="face right">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 4 -->
                            <div class="face left">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 5 -->
                            <div class="face top">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 2 -->
                            <div class="face bottom">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                        </div>
                    </div>
                    <div id="dice-result-mobile">Rolled: </div>
                    <button id="roll-btn-mobile">Roll Dice</button>
                </div>

                <div class="wall-section">
                    <!-- visible place-wall button for mobile -->
                    <button id="place-wall-btn-mobile" disabled>Place Wall</button>
                    <div id="walls-left-mobile">Walls Left: 3</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="settings-card">
            <h2 class="settings-title">Game Settings</h2>
            <div class="settings-option">
                <div style="display: flex; align-items: center;">
                    <span class="sound-icon">ðŸ”Š</span>
                    <span class="option-label">Sound</span>
                </div>
                <div class="sound-toggle active" id="sound-toggle"></div>
            </div>
            <button class="close-settings" id="close-settings">Close Settings</button>
        </div>
    </div>

    <!-- Onboarding Info Modal -->
    <div id="onboarding-overlay" class="info-overlay">
        <div class="info-modal" id="onboarding-modal">
            <p id="onboarding-text">You are <strong id="onboarding-color">Yellow</strong>. You have to escape from our
                opposite entry point. Click roll dice</p>
            <button class="ok-btn" id="onboarding-ok">OK</button>
        </div>
    </div>

    <!-- Six-info Modal -->
    <div id="six-overlay" class="info-overlay">
        <div class="info-modal" id="six-modal">
            <p>When ever 6 is come you have 2 mode: move token or place wall to block any other â€” use it strategically.
            </p>
            <button class="ok-btn" id="six-ok">OK</button>
        </div>
    </div>

    <!-- Color Selection Screen -->
    <div id="color-selection">
        <div class="selection-card">
            <h2 class="selection-title">Choose Your Color</h2>
            <div class="color-options">
                <div class="color-option" data-color="yellow" style="background-color: #ffd500;">Yellow</div>
                <div class="color-option" data-color="green" style="background-color: #68DD00;">Green</div>
                <div class="color-option" data-color="blue" style="background-color: #3370ff;">Blue</div>
                <div class="color-option" data-color="red" style="background-color: #ff4d4d;">Red</div>
            </div>
            <button id="start-game-btn">Start Game</button>
        </div>
    </div>

    <!-- Win Overlay -->
    <div id="win-overlay">
        <div class="win-card">
            <div id="win-text"></div>
            <button id="reset-btn">Play Again</button>
        </div>
    </div>

    <!-- Hidden audio elements -->
    <audio id="dice-sound" preload="auto">
        <source src="dice.mp3" type="audio/mpeg">
    </audio>
    <audio id="goti-move-sound" preload="auto">
        <source src="goti_move.mp3" type="audio/mpeg">
    </audio>
    <audio id="win-sound" preload="auto">
        <source src="win.mp3" type="audio/mpeg">
    </audio>
    <audio id="lose-sound" preload="auto">
        <source src="lose.mp3" type="audio/mpeg">
    </audio>
    <audio id="wall-sound" preload="auto">
        <source src="wall.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Game variables and state (same as before)
        const rows = 14;
        const cols = 17;
        const pinSVG = '<svg viewBox="0 0 24 24" fill="white"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>';
        const positionToElement = {};

        // Game state
        const startYellow = [0, 8];
        const startGreen = [7, 0];
        const startBlue = [7, 16];
        const startRed = [13, 8];
        const centerYellow = [0, 8];
        const centerGreen = [7, 0];
        const centerBlue = [7, 16];
        const centerRed = [13, 8];

        let paths = null;
        let gotis = {};
        const allColors = ['yellow', 'green', 'blue', 'red'];
        let activeColors = ['yellow', 'green', 'blue', 'red'];
        let turnOrder = activeColors.slice();
        let currentTurn = 0;
        let turnSeq = 0;
        let currentPositions = { yellow: 0, green: 0, blue: 0, red: 0 };
        let isUnlocked = { yellow: false, green: false, blue: false, red: false };
        let forwardHighlighted = null;
        let backwardHighlighted = null;
        let rollValue = 0;
        let moveSteps = 0;
        let canPlaceWallThisTurn = false;
        let hasPlacedWallThisTurn = false;
        let reachableTargets = new Set();
        let bfsParents = new Map();
        let bfsStartKey = '';
        let hasRolledThisTurn = false;
        let placingWall = false;
        const walls = { yellow: [], green: [], blue: [], red: [] };
        const wallCellToOwner = new Map();
        const wallsPerColorLimit = 3;
        const wallCounts = { yellow: 3, green: 3, blue: 3, red: 3 };
        let completed = { yellow: false, green: false, blue: false, red: false };
        let finishOrder = [];
        let currentMode = '1v3';
        let humanColor = 'yellow';
        let botColors = new Set(['green', 'blue', 'red']);

        // Game state management
        let gameActive = true;

        // Sound settings
        let soundEnabled = true;

        // DOM Elements
        const gridContainer = document.getElementById('grid-container');
        const rollBtnMobile = document.getElementById('roll-btn-mobile');
        const placeWallBtnMobile = document.getElementById('place-wall-btn-mobile');
        const wallsLeftElMobile = document.getElementById('walls-left-mobile');
        const currentTurnElMobile = document.getElementById('current-turn-mobile');
        const youColorElMobile = document.getElementById('you-color-mobile');
        const diceResultMobile = document.getElementById('dice-result-mobile');
        const hamburgerMenu = document.querySelector('.hamburger-menu');
        const hamburgerDropdown = document.getElementById('hamburger-dropdown');
        const viewRulesBtn = document.getElementById('view-rules-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const resetGameBtn = document.getElementById('reset-game-btn');
        const homeIcon = document.querySelector('.home-icon');
        const diceMobile = document.getElementById('dice-mobile');
        const winOverlay = document.getElementById('win-overlay');
        const winText = document.getElementById('win-text');
        const resetBtn = document.getElementById('reset-btn');
        const colorSelection = document.getElementById('color-selection');
        const colorOptions = document.querySelectorAll('.color-option');
        const startGameBtn = document.getElementById('start-game-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings');
        const soundToggle = document.getElementById('sound-toggle');

        // Audio elements
        const diceSound = document.getElementById('dice-sound');
        const gotiMoveSound = document.getElementById('goti-move-sound');
        const winSound = document.getElementById('win-sound');
        const loseSound = document.getElementById('lose-sound');
        const wallSound = document.getElementById('wall-sound');

        // Initialize game
        function initGame() {
            createBoard();
            createGotis();
            setupEventListeners();
            updateWallsLeftUI();
            renderWallStacks();
            updateRollButtonState();
            loadSoundSetting();
            try { localStorage.removeItem('deceptionist_game_state'); } catch (e) { }
        }

        // Hamburger menu functionality
        function setupHamburgerMenu() {
            hamburgerMenu.addEventListener('click', (e) => {
                e.stopPropagation();
                hamburgerDropdown.classList.toggle('show');
            });

            // Close hamburger menu when clicking outside
            document.addEventListener('click', () => {
                hamburgerDropdown.classList.remove('show');
            });

            // Hamburger menu items
            viewRulesBtn.addEventListener('click', () => {
                window.open('./rule_book.html', '_blank');
                hamburgerDropdown.classList.remove('show');
            });

            settingsBtn.addEventListener('click', () => {
                openSettings();
                hamburgerDropdown.classList.remove('show');
            });

            resetGameBtn.addEventListener('click', () => {
                localStorage.removeItem('deceptionist_game_state');
                window.location.reload();
                hamburgerDropdown.classList.remove('show');
            });

            // Home icon functionality
            homeIcon.addEventListener('click', () => {
                // Add home functionality here, e.g., go to main menu
                window.location.href = 'index.html';
            });
        }

        // Modal helpers
        const onboardingOverlay = document.getElementById('onboarding-overlay');
        const onboardingOk = document.getElementById('onboarding-ok');
        const onboardingTextEl = document.getElementById('onboarding-text');

        const sixOverlay = document.getElementById('six-overlay');
        const sixOk = document.getElementById('six-ok');

        let botSpeedMultiplier = 1;
        const humanSixCount = { yellow: 0, green: 0, blue: 0, red: 0 };
        const sixModalShownFor = { yellow: false, green: false, blue: false, red: false };
        let shouldSpeedOnSixOk = false;

        function showOnboardingFor(color) {
            const colorName = color.charAt(0).toUpperCase() + color.slice(1);
            const oppositeMap = { yellow: 'Red', red: 'Yellow', green: 'Blue', blue: 'Green' };
            const opposite = oppositeMap[color] || '';
            const onboardingText = document.getElementById('onboarding-text');
            if (onboardingText) onboardingText.innerHTML = `You are <strong>${colorName}</strong>. You have to escape from <strong>${opposite}</strong>.`;
            onboardingOverlay.style.display = 'flex';
            rollBtnMobile.classList.add('glow');
        }

        function hideOnboarding() {
            onboardingOverlay.style.display = 'none';
            rollBtnMobile.classList.remove('glow');
        }

        function showSixInfo() {
            sixOverlay.style.display = 'flex';
            placeWallBtnMobile.classList.add('glow');
        }

        function hideSixInfo() {
            sixOverlay.style.display = 'none';
            placeWallBtnMobile.classList.remove('glow');
        }

        // Setup event listeners
        function setupEventListeners() {
            setupHamburgerMenu();

            // Roll button
            // rollBtnMobile is hidden on mobile; the dice icon proxies the roll
            rollBtnMobile.addEventListener('click', handleRoll);

            // Dice click handlers
            if (diceMobile) {
                diceMobile.addEventListener('click', handleRoll);
                diceMobile.style.cursor = 'pointer';
            }

            // Place wall button
            placeWallBtnMobile.addEventListener('click', toggleWallPlacement);

            // Dice icon click -> proxy to roll
            const diceIcon = document.getElementById('dice-icon-mobile');
            if (diceIcon) {
                diceIcon.addEventListener('click', () => {
                    // respect same disabled logic as rollBtnMobile
                    if (rollBtnMobile && rollBtnMobile.disabled) return;
                    handleRoll();
                });
            }

            // Reset button
            resetBtn.addEventListener('click', () => {
                localStorage.removeItem('deceptionist_game_state');
                window.location.href = 'deceptionist.html';
            });

            // Color selection
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    humanColor = option.dataset.color;
                    const youColorElMobile = document.getElementById('you-color-mobile');
                    if (youColorElMobile) youColorElMobile.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
                });
            });

            // Start game button
            startGameBtn.addEventListener('click', startGame);

            // Grid cell clicks
            document.querySelectorAll('.grid-item').forEach(box => {
                box.addEventListener('click', handleCellClick);
            });

            // Settings button
            closeSettingsBtn.addEventListener('click', closeSettings);
            soundToggle.addEventListener('click', toggleSound);

            // Close settings modal when clicking outside
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) closeSettings();
            });

            // Modal buttons
            onboardingOk?.addEventListener('click', () => {
                hideOnboarding();
                applyMode(currentMode);
                updateAllGotiSizes();
                updateRollButtonState();
                botTakeTurnIfNeeded();
            });

            sixOk?.addEventListener('click', () => {
                hideSixInfo();
                if (shouldSpeedOnSixOk) {
                    botSpeedMultiplier = 2;
                    shouldSpeedOnSixOk = false;
                }
            });
        }

        // Start the game after color selection
        function startGame() {
            colorSelection.style.display = 'none';
            showOnboardingFor(humanColor);
        }

        // Apply mode settings
        function applyMode(mode) {
            botColors = new Set();
            allColors.forEach(color => {
                if (color !== humanColor) {
                    botColors.add(color);
                }
            });

            activeColors = allColors.slice();
            turnOrder = activeColors.slice();

            const humanIndex = turnOrder.indexOf(humanColor);
            if (humanIndex > 0) {
                turnOrder.splice(humanIndex, 1);
                turnOrder.unshift(humanColor);
                currentTurn = 0;
            }

            updateVisibility();
            updateTurnDisplay();
        }

        // Update turn display
        function updateTurnDisplay() {
            const color = turnOrder[currentTurn];
            const displayText = `This Turn: ${color.charAt(0).toUpperCase() + color.slice(1)}`;
            currentTurnElMobile.textContent = displayText;
            updateDiceColor(color);
        }

        // Update dice color
        function updateDiceColor(color) {
            const colorMap = {
                yellow: '#ffd500',
                green: '#68DD00',
                blue: '#3370ff',
                red: '#ff4d4d'
            };

            const diceColor = colorMap[color] || '#ffffff';
            const diceFaces = document.querySelectorAll('#dice-mobile .face');
            diceFaces.forEach(face => {
                face.style.background = diceColor;
            });
        }

        // Update piece visibility
        function updateVisibility() {
            allColors.forEach(c => {
                const el = gotis[c]?.goti;
                if (!el) return;
                el.style.display = activeColors.includes(c) ? 'block' : 'none';
            });
        }

        // Handle roll button click
        function handleRoll() {
            const color = turnOrder[currentTurn];

            if (botColors.has(color)) return;
            if (hasRolledThisTurn) return;
            if (!gameActive) return;

            hasRolledThisTurn = true;
            clearAllHighlights();
            rollValue = Math.floor(Math.random() * 6) + 1;

            playDiceSound();
            showDice(rollValue);
            moveSteps = rollValue;
            canPlaceWallThisTurn = (rollValue === 6);
            updateWallButtonVisibility();

            const gotiData = gotis[color];

            if (!botColors.has(color) && rollValue === 6) {
                humanSixCount[color] = (humanSixCount[color] || 0) + 1;
                if (humanSixCount[color] === 2 && !sixModalShownFor[color]) {
                    sixModalShownFor[color] = true;
                    shouldSpeedOnSixOk = true;
                    showSixInfo();
                    const onceHandler = () => {
                        sixOk.removeEventListener('click', onceHandler);
                        processRoll(color, gotiData);
                    };
                    sixOk.addEventListener('click', onceHandler);
                    showDice(rollValue, () => { });
                } else {
                    showDice(rollValue, () => processRoll(color, gotiData));
                }
            } else {
                showDice(rollValue, () => processRoll(color, gotiData));
            }
        }

        // Update wall button visibility
        function updateWallButtonVisibility() {
            const color = turnOrder[currentTurn];
            const isHumanTurn = color && !botColors.has(color);
            const shouldEnableWallButton = isHumanTurn && canPlaceWallThisTurn && wallCounts[color] > 0 && gameActive;
            placeWallBtnMobile.disabled = !shouldEnableWallButton;
        }

        // Process the roll result
        function processRoll(color, gotiData) {
            if (!isUnlocked[color]) {
                if (rollValue === 6) {
                    isUnlocked[color] = true;
                    placeGotiAtCell(color, gotiData.r, gotiData.c);
                    relayoutAllOccupants();
                    canPlaceWallThisTurn = false;
                    updateWallButtonVisibility();
                    nextTurn();
                    return;
                } else {
                    nextTurn();
                    return;
                }
            }

            const { targets, parents, startKey } = bfsReachableExact(gotiData.r, gotiData.c, moveSteps, color);
            reachableTargets = targets;
            bfsParents = parents;
            bfsStartKey = startKey;

            const tint = colorTint(color);
            reachableTargets.forEach(key => {
                if (key === startKey) return;
                const el = positionToElement[key];
                if (el) {
                    el.style.background = tint.bg;
                    el.style.border = tint.border;
                }
            });

            if (!reachableTargets.size || (reachableTargets.size === 1 && reachableTargets.has(startKey))) {
                nextTurn();
            }
        }

        // Handle cell click
        function handleCellClick(e) {
            const box = e.currentTarget;
            if (!gameActive) return;

            if (placingWall) {
                const color = turnOrder[currentTurn];
                if (botColors.has(color)) return;

                const r = parseInt(box.dataset.r);
                const c = parseInt(box.dataset.c);
                const placed = placeWall(color, r, c);

                if (placed) {
                    hasPlacedWallThisTurn = true;
                    canPlaceWallThisTurn = false;
                    updateWallButtonVisibility();
                    clearAllHighlights();
                    exitWallPlacementMode();
                    nextTurn();
                }
                return;
            }

            const color = turnOrder[currentTurn];
            if (botColors.has(color)) return;

            const key = `${box.dataset.r}-${box.dataset.c}`;
            if (reachableTargets.has(key) && key !== bfsStartKey) {
                canPlaceWallThisTurn = false;
                updateWallButtonVisibility();
                if (placingWall) exitWallPlacementMode();
                moveToTargetKey(color, key);
            }
        }

        // Move piece to target cell
        function moveToTargetKey(color, targetKey) {
            const gotiData = gotis[color];
            const pathKeys = [];
            let cur = targetKey;
            pathKeys.push(cur);

            while (cur !== bfsStartKey) {
                const p = bfsParents.get(cur);
                if (!p) break;
                cur = p;
                pathKeys.push(cur);
            }

            pathKeys.reverse();
            let stepIndex = 1;

            function stepAnim() {
                if (stepIndex < pathKeys.length) {
                    const [r, c] = pathKeys[stepIndex].split('-').map(Number);
                    const cellWidth = 100 / cols;
                    const cellHeight = 100 / rows;
                    gotiData.goti.style.left = (c * cellWidth + cellWidth / 2) + '%';
                    gotiData.goti.style.top = (r * cellHeight + cellHeight / 2) + '%';
                    gotiData.r = r;
                    gotiData.c = c;
                    stepIndex++;

                    const delay = botColors.has(color) ? Math.max(80, 450 / Math.max(1, botSpeedMultiplier)) : 450;
                    setTimeout(stepAnim, delay);
                } else {
                    stopGotiMoveSound();
                    relayoutAllOccupants();
                    clearAllHighlights();

                    const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
                    const [gr, gc] = goals[color];
                    if (gotiData.r === gr && gotiData.c === gc) {
                        saveGameState();
                        showWin(color);
                    } else {
                        saveGameState();
                        nextTurn();
                    }
                }
            }

            playGotiMoveSound();
            stepAnim();
        }

        // Bot logic (simplified for brevity)
        function botTakeTurnIfNeeded() {
            const color = turnOrder[currentTurn];
            const token = turnSeq;

            if (!botColors.has(color)) return;
            if (!gameActive) return;
            if (isAtGoal(color)) {
                nextTurn();
                return;
            }

            clearAllHighlights();
            rollValue = Math.floor(Math.random() * 6) + 1;
            moveSteps = rollValue;
            canPlaceWallThisTurn = (rollValue === 6);
            const gotiData = gotis[color];

            playDiceSound();

            showDice(rollValue, () => {
                if (!isUnlocked[color]) {
                    if (rollValue === 6) {
                        isUnlocked[color] = true;
                        placeGotiAtCell(color, gotiData.r, gotiData.c);
                        relayoutAllOccupants();
                        canPlaceWallThisTurn = false;
                        nextTurn();
                        return;
                    } else {
                        nextTurn();
                        return;
                    }
                }

                const { targets, parents, startKey } = bfsReachableExact(gotiData.r, gotiData.c, moveSteps, color);
                reachableTargets = targets;
                bfsParents = parents;
                bfsStartKey = startKey;

                // Bot wall placement logic would go here
                // For now, just move the bot
                setTimeout(() => {
                    if (token !== turnSeq) return;
                    if (!gameActive) return;

                    const key = chooseBestTargetForBot(color);
                    if (key) {
                        moveToTargetKey(color, key);
                    } else {
                        nextTurn();
                    }
                }, 400 / Math.max(1, botSpeedMultiplier));
            });
        }

        // Choose best target for bot
        function chooseBestTargetForBot(color) {
            const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
            const goal = goals[color];
            let bestKey = null;
            let bestScore = Infinity;

            function manhattan(a, b) {
                return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
            }

            const opponents = turnOrder.filter(c => c !== color && !completed[c]);
            const opponentPositions = opponents.map(c => gotis[c]).filter(p => p);

            reachableTargets.forEach(key => {
                if (key === bfsStartKey) return;
                const [r, c] = key.split('-').map(Number);
                const pathToGoal = computePath([r, c], goal) || [];
                const len = Math.max(0, pathToGoal.length - 1);

                let minOppDist = Infinity;
                for (const op of opponentPositions) {
                    if (!op) continue;
                    const d = manhattan([r, c], [op.r, op.c]);
                    if (d < minOppDist) minOppDist = d;
                }
                if (minOppDist === Infinity) minOppDist = 10;

                let wallPenalty = 0;
                for (let dr = -2; dr <= 2; dr++) {
                    for (let dc = -2; dc <= 2; dc++) {
                        const k = `${r + dr}-${c + dc}`;
                        if (wallCellToOwner.has(k)) {
                            const w = wallCellToOwner.get(k);
                            if (w && w.owner !== color) wallPenalty += 1;
                            else wallPenalty += 0.2;
                        }
                    }
                }

                const score = len * 10 - Math.min(8, minOppDist) * 3 + wallPenalty * 6;
                if (score < bestScore) {
                    bestScore = score;
                    bestKey = key;
                }
            });

            if (!bestKey) {
                for (const key of reachableTargets) {
                    if (key !== bfsStartKey) {
                        bestKey = key;
                        break;
                    }
                }
            }

            return bestKey;
        }

        // Wall placement functions
        function toggleWallPlacement() {
            const color = turnOrder[currentTurn];
            if (botColors.has(color)) return;
            if (wallCounts[color] <= 0) return;
            if (!canPlaceWallThisTurn) return;
            if (!gameActive) return;

            if (!placingWall) {
                enterWallPlacementMode();
            } else {
                exitWallPlacementMode();
            }
        }

        function enterWallPlacementMode() {
            placingWall = true;
            document.querySelectorAll('.grid-item').forEach(el => {
                el.style.outline = '3px dashed rgba(255,255,255,0.5)';
            });
            placeWallBtnMobile.textContent = 'Cancel Wall';
        }

        function exitWallPlacementMode() {
            placingWall = false;
            document.querySelectorAll('.grid-item').forEach(el => {
                el.style.outline = '';
            });
            placeWallBtnMobile.textContent = 'Place Wall';
        }

        function placeWall(color, r, c) {
            if (!activeColors.includes(color)) return false;
            if (wallCounts[color] <= 0) return false;

            const key = `${r}-${c}`;
            if (!positionToElement[key]) return false;
            if (wallCellToOwner.has(key)) return false;

            const cell = positionToElement[key];
            if (cell && cell.querySelector('.location-icon')) return false;

            for (const col of allColors) {
                const info = gotis[col];
                if (!info) continue;
                if (info.r === r && info.c === c) return false;
            }

            const ok = renderWallAt(r, c, color);
            if (!ok) return false;

            const remainingTurns = 3;
            walls[color].push({ r, c, remainingTurns });
            wallCellToOwner.set(key, { owner: color, remainingTurns });
            wallCounts[color] -= 1;

            updateWallsLeftUI();
            renderWallStacks();
            saveGameState();
            return true;
        }

        function renderWallAt(r, c, owner) {
            const key = `${r}-${c}`;
            const cell = positionToElement[key];
            if (!cell) return false;
            if (wallCellToOwner.has(key)) return false;

            const overlay = document.createElement('div');
            overlay.className = 'wall-overlay';
            overlay.style.position = 'absolute';
            overlay.style.inset = '2px';

            const colorMap = {
                yellow: { bg: 'rgba(255,213,0,0.35)', border: '#ffd500' },
                green: { bg: 'rgba(104,221,0,0.35)', border: '#68DD00' },
                blue: { bg: 'rgba(51,112,255,0.35)', border: '#3370ff' },
                red: { bg: 'rgba(255,77,77,0.35)', border: '#ff4d4d' }
            };

            const cfg = colorMap[owner] || colorMap.red;
            overlay.style.background = cfg.bg;
            overlay.style.border = '3px solid ' + cfg.border;
            overlay.style.pointerEvents = 'none';
            cell.appendChild(overlay);

            playWallSound();
            return true;
        }

        function removeWallAtKey(key) {
            wallCellToOwner.delete(key);
            const el = positionToElement[key];
            if (el) {
                const overlay = el.querySelector('.wall-overlay');
                if (overlay) el.removeChild(overlay);
            }
        }

        function tickWallsFor(ownerColor) {
            const arr = walls[ownerColor];
            if (!arr) return;

            for (let i = arr.length - 1; i >= 0; i--) {
                const w = arr[i];
                w.remainingTurns -= 1;
                const key = `${w.r}-${w.c}`;
                const entry = wallCellToOwner.get(key);
                if (entry && entry.owner === ownerColor) entry.remainingTurns = w.remainingTurns;

                if (w.remainingTurns <= 0) {
                    removeWallAtKey(key);
                    arr.splice(i, 1);
                }
            }
        }

        // UI update functions
        function updateWallsLeftUI() {
            const color = turnOrder[currentTurn] || 'yellow';
            const shown = wallCounts[color];
            wallsLeftElMobile.textContent = `Walls Left: ${shown}`;
        }

        function updateRollButtonState() {
            const color = turnOrder[currentTurn];
            const isHumanTurn = color && !botColors.has(color);
            rollBtnMobile.disabled = !isHumanTurn || !gameActive;
            rollBtnMobile.style.opacity = isHumanTurn && gameActive ? '1' : '0.6';
            rollBtnMobile.style.cursor = isHumanTurn && gameActive ? 'pointer' : 'not-allowed';

            updateWallButtonVisibility();

            // reflect state on dice icon
            const diceIcon = document.getElementById('dice-icon-mobile');
            if (diceIcon) {
                if (!isHumanTurn || !gameActive) {
                    diceIcon.classList.add('disabled');
                } else {
                    diceIcon.classList.remove('disabled');
                }
            }

            const colorMapBtn = {
                yellow: 'linear-gradient(135deg, #ffd500, #e6c200)',
                green: 'linear-gradient(135deg, #68DD00, #4db200)',
                blue: 'linear-gradient(135deg, #3370ff, #2158d8)',
                red: 'linear-gradient(135deg, #ff4d4d, #ff1f1f)'
            };
            const btnBg = colorMapBtn[color] || 'linear-gradient(135deg, #4CAF50, #45a049)';
            rollBtnMobile.style.background = btnBg;
            placeWallBtnMobile.style.background = btnBg;
        }

        function renderWallStacks() {
            const container = document.getElementById('wall-stacks');
            if (!container) return;

            container.innerHTML = '';
            const cfg = [
                { color: 'red', bg: '#ff4d4d' },
                { color: 'green', bg: '#68DD00' },
                { color: 'yellow', bg: '#ffd500' },
                { color: 'blue', bg: '#3370ff' }
            ];

            cfg.forEach(({ color, bg }) => {
                const col = document.createElement('div');
                col.className = 'wall-stack-column';

                for (let i = 0; i < 3; i++) {
                    const block = document.createElement('div');
                    block.className = 'wall-block';
                    block.style.background = (i < wallCounts[color]) ? bg : 'transparent';
                    col.appendChild(block);
                }

                container.appendChild(col);
            });
        }

        // Game state functions
        function nextTurn(skipIncrement) {
            if (!skipIncrement) currentTurn = (currentTurn + 1) % turnOrder.length;

            let guard = 0;
            while (completed[turnOrder[currentTurn]] && guard < 10) {
                currentTurn = (currentTurn + 1) % turnOrder.length;
                guard++;
            }

            turnSeq++;
            const color = turnOrder[currentTurn];

            tickWallsFor(color);
            updateTurnDisplay();
            updateWallsLeftUI();
            updateRollButtonState();

            rollValue = 0;
            hasRolledThisTurn = false;
            canPlaceWallThisTurn = false;
            hasPlacedWallThisTurn = false;
            updateWallButtonVisibility();
            placeWallBtnMobile.textContent = 'Place Wall';

            if (placingWall) exitWallPlacementMode();

            clearAllHighlights();

            setTimeout(botTakeTurnIfNeeded, 500 / Math.max(1, botSpeedMultiplier));
            saveGameState();
        }

        function showWin(color) {
            gameActive = false;
            completed[color] = true;

            moveGotiToWallPosition(color);
            removeAllWallsForColor(color);

            turnOrder = turnOrder.filter(c => !completed[c]);

            if (turnOrder.length > 0) {
                currentTurn = currentTurn % turnOrder.length;
            }

            relayoutAllOccupants();
            finishOrder.push(color);

            let botsDone = 0;
            botColors.forEach(bc => { if (completed[bc]) botsDone++; });

            if (botsDone === botColors.size && !completed[humanColor]) {
                playLoseSound();
                endGameWithMessage('You Lose! Read & Understand Rules.');
                return;
            }

            playWinSound();

            if (!turnOrder.length) {
                endGameWithMessage('Game Over');
                return;
            }

            if (color === humanColor) {
                const rank = finishOrder.indexOf(humanColor) + 1;
                if (rank === 1) {
                    playWinSound();
                    endGameWithMessage('You Win! You Got 1st Position');
                } else if (rank === 2) {
                    endGameWithMessage('You Got 2nd Position, Better Luck Next Time!');
                } else if (rank === 3) {
                    endGameWithMessage('You Got 3rd Position, Try Again!');
                }
                return;
            }

            gameActive = true;
            updateRollButtonState();
            nextTurn(true);
        }

        function endGameWithMessage(message) {
            gameActive = false;
            winText.textContent = message;
            winOverlay.style.display = 'flex';
        }

        function resetGame() {
            window.location.href = "index.html";
        }

        // Sound functions
        function playDiceSound() {
            if (!soundEnabled) return;
            if (diceSound) {
                diceSound.currentTime = 0;
                diceSound.play().catch(e => console.log("Audio play failed:", e));
            }
        }

        function playGotiMoveSound() {
            if (!soundEnabled) return;
            if (gotiMoveSound) {
                gotiMoveSound.currentTime = 0;
                gotiMoveSound.play().catch(e => console.log("Audio play failed:", e));
            }
        }

        function stopGotiMoveSound() {
            if (gotiMoveSound) {
                try {
                    gotiMoveSound.pause();
                    gotiMoveSound.currentTime = 0;
                } catch (e) {
                    // ignore errors when stopping audio
                }
            }
        }

        function playWallSound() {
            if (!soundEnabled) return;
            if (wallSound) {
                wallSound.currentTime = 0;
                wallSound.play().catch(e => console.log("Wall sound play failed:", e));
            }
        }

        function playWinSound() {
            if (!soundEnabled) return;
            if (winSound) {
                try {
                    winSound.currentTime = 0;
                    winSound.play().catch(e => console.log('Win sound play failed:', e));
                } catch (e) {
                    // ignore
                }
            }
        }

        function playLoseSound() {
            if (!soundEnabled) return;
            if (loseSound) {
                try {
                    loseSound.currentTime = 0;
                    loseSound.play().catch(e => console.log('Lose sound play failed:', e));
                } catch (e) {
                    // ignore
                }
            }
        }

        function stopAllSounds() {
            try {
                if (diceSound) {
                    diceSound.pause();
                    diceSound.currentTime = 0;
                }
                if (gotiMoveSound) {
                    gotiMoveSound.pause();
                    gotiMoveSound.currentTime = 0;
                }
                if (wallSound) {
                    wallSound.pause();
                    wallSound.currentTime = 0;
                }
                if (winSound) {
                    winSound.pause();
                    winSound.currentTime = 0;
                }
                if (loseSound) {
                    loseSound.pause();
                    loseSound.currentTime = 0;
                }
            } catch (e) {
                // ignore any errors stopping audio
            }
        }

        // Settings functions
        function openSettings() {
            settingsModal.style.display = 'flex';
        }

        function closeSettings() {
            settingsModal.style.display = 'none';
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('active', soundEnabled);
            localStorage.setItem('deceptionist_sound_enabled', soundEnabled.toString());
            if (!soundEnabled) {
                stopAllSounds();
            }
        }

        function loadSoundSetting() {
            const savedSoundSetting = localStorage.getItem('deceptionist_sound_enabled');
            if (savedSoundSetting !== null) {
                soundEnabled = savedSoundSetting === 'true';
                soundToggle.classList.toggle('active', soundEnabled);
                if (!soundEnabled) stopAllSounds();
            }
        }

        // Utility functions (abbreviated for space)
        function neighborsOf(r, c) {
            const deltas = [[1, 0], [-1, 0], [0, 1], [0, -1]];
            const result = [];
            for (const [dr, dc] of deltas) {
                const nr = r + dr;
                const nc = c + dc;
                const key = `${nr}-${nc}`;
                if (positionToElement[key]) result.push([nr, nc]);
            }
            return result;
        }

        function computePath(start, goal) {
            const startKey = `${start[0]}-${start[1]}`;
            const goalKey = `${goal[0]}-${goal[1]}`;
            const queue = [start];
            const visited = new Set([startKey]);
            const parent = new Map();

            while (queue.length) {
                const [r, c] = queue.shift();
                const key = `${r}-${c}`;
                if (key === goalKey) break;

                for (const [nr, nc] of neighborsOf(r, c)) {
                    const nkey = `${nr}-${nc}`;
                    if (!visited.has(nkey)) {
                        visited.add(nkey);
                        parent.set(nkey, key);
                        queue.push([nr, nc]);
                    }
                }
            }

            if (!parent.size && startKey !== goalKey) return [start];
            const path = [];
            let cur = goalKey;
            path.push([goal[0], goal[1]]);

            while (cur !== startKey) {
                const prev = parent.get(cur);
                if (!prev) break;
                const [pr, pc] = prev.split('-').map(Number);
                path.push([pr, pc]);
                cur = prev;
            }

            path.push([start[0], start[1]]);
            path.reverse();
            return path;
        }

        function canEnterCell(color, r, c) {
            const key = `${r}-${c}`;
            const entry = wallCellToOwner.get(key);
            if (!entry) return true;
            return entry.owner === color;
        }

        function bfsReachableExact(startR, startC, steps, moverColor) {
            const startKey = `${startR}-${startC}`;
            const queue = [[startR, startC, 0]];
            const visited = new Set([startKey]);
            const parents = new Map();
            const targets = new Set();

            while (queue.length) {
                const [r, c, d] = queue.shift();
                if (d === steps) {
                    targets.add(`${r}-${c}`);
                    continue;
                }

                for (const [nr, nc] of neighborsOf(r, c)) {
                    if (!canEnterCell(moverColor, nr, nc)) continue;
                    const key = `${nr}-${nc}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        parents.set(key, `${r}-${c}`);
                        queue.push([nr, nc, d + 1]);
                    }
                }
            }

            return { targets, parents, startKey };
        }

        function clearAllHighlights() {
            if (reachableTargets.size) {
                reachableTargets.forEach(key => {
                    const el = positionToElement[key];
                    if (el) {
                        el.classList.remove('highlighted-forward');
                        el.classList.remove('highlighted-backward');
                        const baseBg = el.dataset.baseBg || '';
                        el.style.background = baseBg;
                        el.style.border = el.dataset.baseBorder || '2px solid black';
                    }
                });
            }

            reachableTargets = new Set();
            bfsParents = new Map();
            bfsStartKey = '';

            if (forwardHighlighted) {
                forwardHighlighted.classList.remove('highlighted-forward');
                forwardHighlighted = null;
            }

            if (backwardHighlighted) {
                backwardHighlighted.classList.remove('highlighted-backward');
                backwardHighlighted = null;
            }
        }

        function colorTint(color) {
            if (color === 'yellow') return { bg: 'rgba(255,255,0,0.35)', border: '3px solid #b3b300' };
            if (color === 'green') return { bg: 'rgba(104,221,0,0.35)', border: '3px solid #3a8f00' };
            if (color === 'blue') return { bg: 'rgba(0,0,255,0.35)', border: '3px solid #001a99' };
            return { bg: 'rgba(255,0,0,0.35)', border: '3px solid #990000' };
        }

        function isAtGoal(color) {
            const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
            const [gr, gc] = goals[color];
            const g = gotis[color];
            return g.r === gr && g.c === gc;
        }

        function placeGotiAtCell(color, r, c) {
            const gotiData = gotis[color];
            const cellWidthPct = 100 / cols;
            const cellHeightPct = 100 / rows;
            const sizePct = Math.min(cellWidthPct, cellHeightPct) * 0.7;

            gotiData.goti.style.width = sizePct + '%';
            gotiData.goti.style.height = sizePct + '%';
            gotiData.goti.style.left = (c * cellWidthPct + cellWidthPct / 2) + '%';
            gotiData.goti.style.top = (r * cellHeightPct + cellHeightPct / 2) + '%';
            gotiData.r = r;
            gotiData.c = c;

            relayoutAllOccupants();
        }

        function placeGotiAtHome(color) {
            const goti = gotis[color].goti;
            const cellW = 100 / cols;
            const cellH = 100 / rows;
            const sizePct = Math.min(cellW, cellH) * 0.7;

            goti.style.width = sizePct + '%';
            goti.style.height = sizePct + '%';

            void goti.offsetWidth;

            const starts = { yellow: startYellow, green: startGreen, blue: startBlue, red: startRed };
            const [sr, sc] = starts[color];

            const order = { red: 0, green: 1, yellow: 2, blue: 3 };
            const wallStacks = document.getElementById('wall-stacks');
            if (wallStacks && wallStacks.children[order[color]]) {
                const column = wallStacks.children[order[color]];
                const topBlock = column.children[0] || column;
                const colRect = column.getBoundingClientRect();
                const topRect = topBlock.getBoundingClientRect();
                const boardRect = document.querySelector('.outer-box').getBoundingClientRect();
                const xAbs = colRect.left + colRect.width / 2;
                const yAbs = topRect.top - (goti.getBoundingClientRect().height / 2) - 8;
                const x = ((xAbs - boardRect.left) / boardRect.width) * 100;
                const y = ((yAbs - boardRect.top) / boardRect.height) * 100;
                goti.style.left = Math.min(96, Math.max(2, x)) + '%';
                goti.style.top = Math.min(96, Math.max(2, y)) + '%';
            } else {
                goti.style.left = (sc * cellW + cellW / 2) + '%';
                goti.style.top = (sr * cellH + cellH / 2) + '%';
            }

            gotis[color].r = sr;
            gotis[color].c = sc;
        }

        function updateAllGotiSizes() {
            const cellW = 100 / cols;
            const cellH = 100 / rows;
            const sizePct = Math.min(cellW, cellH) * 0.7;

            allColors.forEach(color => {
                const g = gotis[color]?.goti;
                if (g) {
                    g.style.width = sizePct + '%';
                    g.style.height = sizePct + '%';

                    if (isUnlocked[color]) {
                        const r = gotis[color].r;
                        const c = gotis[color].c;
                        g.style.left = (c * cellW + cellW / 2) + '%';
                        g.style.top = (r * cellH + cellH / 2) + '%';
                    } else {
                        placeGotiAtHome(color);
                    }
                }
            });

            relayoutAllOccupants();
        }

        function relayoutAllOccupants() {
            const cellW = 100 / cols;
            const cellH = 100 / rows;
            const normalSize = Math.min(cellW, cellH) * 0.7;
            const smallSize = Math.min(cellW, cellH) * 0.38;
            const byCell = new Map();

            allColors.forEach(color => {
                if (!isUnlocked[color]) return;
                const info = gotis[color];
                const key = `${info.r}-${info.c}`;
                if (!byCell.has(key)) byCell.set(key, []);
                byCell.get(key).push(color);
            });

            allColors.forEach(color => {
                if (!isUnlocked[color]) return;
                const info = gotis[color];
                const g = info.goti;
                g.style.width = normalSize + '%';
                g.style.height = normalSize + '%';
                g.style.left = (info.c * cellW + cellW / 2) + '%';
                g.style.top = (info.r * cellH + cellH / 2) + '%';
            });

            byCell.forEach((colors, key) => {
                if (colors.length <= 1) return;
                const [r, c] = key.split('-').map(Number);

                let offsets;
                if (colors.length === 2) {
                    offsets = [[-0.28, -0.28], [0.28, 0.28]];
                } else if (colors.length === 3) {
                    offsets = [[-0.32, -0.24], [0.32, -0.24], [0.0, 0.32]];
                } else {
                    offsets = [[-0.32, -0.32], [0.32, -0.32], [-0.32, 0.32], [0.32, 0.32]];
                }

                colors.forEach((color, idx) => {
                    const info = gotis[color];
                    const g = info.goti;
                    const off = offsets[Math.min(idx, offsets.length - 1)];
                    g.style.width = smallSize + '%';
                    g.style.height = smallSize + '%';
                    g.style.left = (c * cellW + cellW / 2 + off[0] * cellW) + '%';
                    g.style.top = (r * cellH + cellH / 2 + off[1] * cellH) + '%';
                });
            });
        }

        function moveGotiToWallPosition(color) {
            isUnlocked[color] = false;
            completed[color] = true;
            placeGotiAtHome(color);
        }

        function removeAllWallsForColor(color) {
            walls[color] = [];

            const keysToRemove = [];
            wallCellToOwner.forEach((entry, key) => {
                if (entry.owner === color) {
                    keysToRemove.push(key);
                }
            });

            keysToRemove.forEach(key => {
                removeWallAtKey(key);
            });

            wallCounts[color] = 0;
            updateWallsLeftUI();
            renderWallStacks();
        }

        // Persist / restore state
        function saveGameState() {
            try {
                const state = {
                    currentTurn,
                    turnOrder,
                    currentPositions,
                    isUnlocked,
                    wallCounts,
                    walls,
                    wallCellToOwner: Array.from(wallCellToOwner.entries()),
                    completed,
                    finishOrder,
                    humanColor
                };
                localStorage.setItem('deceptionist_game_state', JSON.stringify(state));
            } catch (e) {
                console.warn('Failed to save game state', e);
            }
        }

        function loadGameState() {
            try {
                const raw = localStorage.getItem('deceptionist_game_state');
                if (!raw) return;
                const state = JSON.parse(raw);
                if (!state) return;

                if (state.turnOrder) turnOrder = state.turnOrder;
                if (typeof state.currentTurn === 'number') currentTurn = state.currentTurn;
                if (state.wallCounts) Object.assign(wallCounts, state.wallCounts);
                if (state.isUnlocked) Object.assign(isUnlocked, state.isUnlocked);
                if (state.completed) Object.assign(completed, state.completed);
                if (Array.isArray(state.finishOrder)) finishOrder = state.finishOrder;
                if (state.humanColor) humanColor = state.humanColor;

                if (state.wallCellToOwner) {
                    wallCellToOwner.clear();
                    state.wallCellToOwner.forEach(([k, v]) => wallCellToOwner.set(k, v));
                }

                if (state.currentPositions) {
                    Object.keys(state.currentPositions).forEach(color => {
                        if (gotis[color]) {
                            const p = state.currentPositions[color];
                            gotis[color].r = p.r ?? gotis[color].r;
                            gotis[color].c = p.c ?? gotis[color].c;
                            if (isUnlocked[color]) {
                                placeGotiAtCell(color, gotis[color].r, gotis[color].c);
                            } else {
                                placeGotiAtHome(color);
                            }
                        }
                    });
                }

                const youColorElMobile = document.getElementById('you-color-mobile');
                if (youColorElMobile) youColorElMobile.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);

                wallCellToOwner.forEach((entry, key) => {
                    const [r, c] = key.split('-').map(Number);
                    renderWallAt(r, c, entry.owner);
                });

                renderWallStacks();
                updateWallsLeftUI();
                updateRollButtonState();
                updateTurnDisplay();

                if (state.turnOrder && state.turnOrder.length > 0) {
                    colorSelection.style.display = 'none';
                    applyMode(currentMode);
                    updateAllGotiSizes();
                }
            } catch (e) {
                console.warn('Failed to load game state', e);
            }
        }

        function showDice(num, callback) {
            const diceMobile = document.getElementById('dice-mobile');
            const diceResultMobile = document.getElementById('dice-result-mobile');
            if (!diceMobile) return;

            diceResultMobile.textContent = `Rolled: ${num}`;

            const rotations = {
                1: { x: 0, y: 0 },
                2: { x: 90, y: 0 },
                3: { x: 0, y: -90 },
                4: { x: 0, y: 90 },
                5: { x: -90, y: 0 },
                6: { x: 180, y: 0 }
            };

            const { x, y } = rotations[num];
            const extraX = 360 * (Math.floor(Math.random() * 3) + 2);
            const extraY = 360 * (Math.floor(Math.random() * 3) + 2);
            const extraZ = 360 * (Math.floor(Math.random() * 3) + 2);

            diceMobile.style.transform = `rotateX(${x + extraX}deg) rotateY(${y + extraY}deg) rotateZ(${extraZ}deg)`;

            if (callback) {
                let called = false;
                const handleTransitionEnd = () => {
                    if (called) return;
                    called = true;
                    diceMobile.removeEventListener('transitionend', handleTransitionEnd);
                    clearTimeout(fallback);
                    callback();
                };
                const fallback = setTimeout(() => {
                    if (called) return;
                    called = true;
                    diceMobile.removeEventListener('transitionend', handleTransitionEnd);
                    callback();
                }, 2000);
                diceMobile.addEventListener('transitionend', handleTransitionEnd);
            }
        }

        // Board creation functions (abbreviated)
        function createBoard() {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const box = document.createElement('div');

                    if (shouldSkipCell(r, c)) {
                        gridContainer.appendChild(box);
                        continue;
                    }

                    if (isSpecialCell(r, c)) {
                        createSpecialCell(box, r, c);
                        continue;
                    }

                    box.className = 'grid-item';
                    box.dataset.r = r.toString();
                    box.dataset.c = c.toString();
                    gridContainer.appendChild(box);
                }
            }

            document.querySelectorAll('.grid-item').forEach(box => {
                const r = parseInt(box.dataset.r);
                const c = parseInt(box.dataset.c);
                positionToElement[`${r}-${c}`] = box;

                if (!box.dataset.baseBorder) box.dataset.baseBorder = box.style.border || '2px solid black';
                if (!box.dataset.baseBg) box.dataset.baseBg = box.style.background || '';
            });

            paths = {
                yellow: computePath(startYellow, centerRed),
                red: computePath(startRed, centerYellow),
                green: computePath(startGreen, centerBlue),
                blue: computePath(startBlue, centerGreen)
            };
        }

        function shouldSkipCell(r, c) {
            const skipPatterns = {
                0: (c) => c < 4 || c >= 11,
                1: (c) => ![4, 7, 10, 11, 12].includes(c),
                2: (c) => ![4, 5, 7, 10, 12].includes(c),
                3: (c) => ![5, 7, 10, 12, 13].includes(c),
                4: (c) => ![1, 2, 3, 4, 5, 6, 7, 8, 10, 13].includes(c),
                5: (c) => ![0, 1, 2, 4, 6, 8, 9, 10, 12, 13, 14, 15, 16].includes(c),
                6: (c) => ![0, 2, 4, 6, 10, 12, 14, 16].includes(c),
                7: (c) => ![0, 2, 4, 6, 10, 12, 14, 16].includes(c),
                8: (c) => ![0, 2, 4, 6, 8, 9, 10, 12, 13, 14, 16].includes(c),
                9: (c) => ![0, 2, 4, 6, 8, 12, 14, 16].includes(c),
                10: (c) => ![0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16].includes(c),
                11: (c) => ![1, 2, 5, 11].includes(c),
                12: (c) => ![2, 5, 11].includes(c),
                13: (c) => ![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].includes(c)
            };

            return skipPatterns[r] ? skipPatterns[r](c) : false;
        }

        function isSpecialCell(r, c) {
            if (r === 0 && [7, 8, 9].includes(c)) return true;
            if ((r === 6 || r === 7 || r === 8) && c === 0) return true;
            if ((r === 6 || r === 7 || r === 8) && c === cols - 1) return true;
            if (r === rows - 1 && (c === 7 || c === 8 || c === 9)) return true;
            return false;
        }

        function createSpecialCell(box, r, c) {
            box.className = 'grid-item';
            box.dataset.r = r.toString();
            box.dataset.c = c.toString();

            if (r === 0 && [8].includes(c)) {
                box.style.background = 'yellow';
                box.style.border = '3px solid black';
                if (c === 8) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(180deg)';
                    box.appendChild(icon);
                }
            }
            else if ((r === 7) && c === 0) {
                box.style.background = '#68DD00';
                box.style.border = '3px solid black';
                if (r === 7) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(90deg)';
                    box.appendChild(icon);
                }
            }
            else if ((r === 7) && c === cols - 1) {
                box.style.background = 'blue';
                box.style.border = '3px solid black';
                if (r === 7) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(270deg)';
                    box.appendChild(icon);
                }
            }
            else if (r === rows - 1 && (c === 8)) {
                box.style.background = 'red';
                box.style.border = '3px solid black';
                if (c === 8) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(0deg)';
                    box.appendChild(icon);
                }
            }

            gridContainer.appendChild(box);
        }

        function createGotis() {
            allColors.forEach(color => {
                let startPos;
                if (color === 'yellow') startPos = [0, 8];
                else if (color === 'green') startPos = [7, 0];
                else if (color === 'blue') startPos = [7, 16];
                else startPos = [13, 8];

                const startKey = `${startPos[0]}-${startPos[1]}`;
                const startBox = positionToElement[startKey];
                const goti = document.createElement('div');
                goti.className = `goti ${color}`;

                if (color === 'yellow') goti.style.backgroundColor = 'yellow';
                else if (color === 'green') goti.style.backgroundColor = '#68DD00';
                else if (color === 'blue') goti.style.backgroundColor = 'blue';
                else goti.style.backgroundColor = 'red';

                goti.style.position = 'absolute';
                document.querySelector('.outer-box').appendChild(goti);
                gotis[color] = { goti: goti, r: startPos[0], c: startPos[1] };
                currentPositions[color] = 0;
                placeGotiAtHome(color);

                goti.style.position = 'absolute';
                document.querySelector('.outer-box').appendChild(goti);
                gotis[color] = { goti: goti, r: startPos[0], c: startPos[1] };
                currentPositions[color] = 0;
            });
            renderEntryArrows();
        }

        function renderEntryArrows() {
            document.querySelectorAll('.entry-arrow').forEach(e => e.remove());
            const outer = document.querySelector('.outer-box');
            if (!outer) return;

            const map = [
                { entry: '0-8', owner: 'yellow', arrowColor: 'red', dir: 'up' },
                { entry: '13-8', owner: 'red', arrowColor: 'yellow', dir: 'down' },
                { entry: '7-0', owner: '#68DD00', arrowColor: 'blue', dir: 'left' },
                { entry: '7-16', owner: 'blue', arrowColor: '#68DD00', dir: 'right' }
            ];

            map.forEach(cfg => {
                const el = positionToElement[cfg.entry];
                if (!el) return;
                const arrow = document.createElement('div');
                arrow.className = 'entry-arrow';
                arrow.style.background = 'transparent';

                let svg = '';
                const fill = cfg.arrowColor;
                const arrowSize = 20;

                if (cfg.dir === 'up') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M12 2 L20 14 H4 L12 2 Z"/></svg>`;
                } else if (cfg.dir === 'down') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M12 22 L4 10 H20 L12 22 Z"/></svg>`;
                } else if (cfg.dir === 'left') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M2 12 L14 4 V20 L2 12 Z"/></svg>`;
                } else if (cfg.dir === 'right') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M22 12 L10 20 V4 L22 12 Z"/></svg>`;
                }

                arrow.innerHTML = svg;

                arrow.style.position = 'absolute';
                arrow.style.width = arrowSize + 'px';
                arrow.style.height = arrowSize + 'px';
                arrow.style.animation = 'none';
                if (cfg.dir === 'up') {
                    arrow.style.left = '50%';
                    arrow.style.top = '-15px';
                    arrow.style.transform = 'translateX(-50%)';
                } else if (cfg.dir === 'down') {
                    arrow.style.left = '50%';
                    arrow.style.bottom = '-15px';
                    arrow.style.transform = 'translateX(-50%)';
                } else if (cfg.dir === 'left') {
                    arrow.style.left = '-15px';
                    arrow.style.top = '50%';
                    arrow.style.transform = 'translateY(-50%)';
                } else if (cfg.dir === 'right') {
                    arrow.style.right = '-15px';
                    arrow.style.top = '50%';
                    arrow.style.transform = 'translateY(-50%)';
                }
                el.style.position = 'relative';
                el.appendChild(arrow);
            });
        }

        // Initialize the game
        window.addEventListener('load', () => {
            initGame();
            colorOptions[0].classList.add('selected');
            const youColorElMobile = document.getElementById('you-color-mobile');
            if (youColorElMobile) youColorElMobile.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
        });

        window.addEventListener('resize', () => {
            updateAllGotiSizes();
            renderWallStacks();
            renderEntryArrows();
        });
    </script>
</body>

</html>