<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deceptionist - Not All Exits Are Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            color: #fff;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            gap: 15px;
        }

        .game-area {
            display: flex;
            flex-direction: row;
            width: 100%;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }

        .board-container {
            flex: 1;
            max-width: 800px;
            position: relative;
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            min-width: 180px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .outer-box {
            position: relative;
            width: 100%;
            aspect-ratio: 4 / 3;
            background-image: url('board_bg.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            border: 4px solid #2d3748;
            padding: 0.5%;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: auto;
            overflow: visible;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            grid-template-rows: repeat(14, 1fr);
            gap: 0.3vw;
            width: 100%;
            height: 100%;
            overflow: visible;
            position: relative;
        }

        .grid-item {
            background: transparent;
            border-radius: 3px;
            border: 2px solid rgba(0, 0, 0, 0.6);
            width: 100%;
            height: 100%;
            position: relative;
            overflow: visible;
            cursor: pointer;
        }

        .location-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 1;
        }

        .goti {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            z-index: 2;
            transition: all 0.3s ease;
            box-shadow:
                0 6px 10px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 255, 255, 0.2);
            /* subtle outer glow for contrast */
        }

        .highlighted-forward {
            background-color: rgba(0, 255, 0, 0.5) !important;
            border: 3px solid green !important;
        }

        .highlighted-backward {
            background-color: rgba(255, 0, 0, 0.5) !important;
            border: 3px solid red !important;
        }

        #dice-container {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        /* small modern label for player's color */
        #you-are {
            font-size: 14px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            color: #fff;
            margin-bottom: 10px;
        }

        #roll-btn {
            padding: 14px 28px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            width: 100%;
        }

        #roll-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        #roll-btn:disabled {
            background: #718096;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Make mobile buttons and labels match the desktop monitor styling */
        /* General mobile button base (will be overridden for place-wall) */
        #roll-btn-mobile,
        #restart-game-btn-mobile,
        #view-mobile {
            padding: 7px 12px;
            font-size: 15px;
            font-weight: 600;
            background: linear-gradient(135deg, #D2E03C, #D2E03C);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            width: 100%;
            display: inline-block;
            text-align: center;
        }

        #set-mobile {
            padding: 7px 12px;
            font-size: 15px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            width: 100%;
            display: inline-block;
            text-align: center;
        }

        /* Make anchor tag wrapper for view-mobile button match the button styling */
        .mobile-top-right a {
            display: flex;
            width: 100%;
            text-decoration: none;
            padding: 0;
            margin: 0;
        }

        .mobile-top-right a button {
            width: 100%;
            padding: 7px 12px;
            margin: 0;
        }

        #roll-btn-mobile:hover,
        #restart-game-btn-mobile:hover,
        #view-mobile:hover,
        #set-mobile:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        #roll-btn-mobile:disabled {
            background: #718096;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Mobile place-wall button should use the same orange style as desktop */
        #place-wall-btn-mobile {
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            background: linear-gradient(135deg, #FF9800, #e68900);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s;
            width: 100%;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        #place-wall-btn-mobile:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.4);
        }

        #place-wall-btn-mobile:disabled {
            background: #718096;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Mobile labels mirror desktop small labels */
        #you-are-mobile {
            font-size: 14px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            color: #fff;
            margin-bottom: 6px;
            display: inline-block;
        }

        #current-turn-mobile,
        #dice-result-mobile,
        #walls-left-mobile {
            font-size: 16px;
            font-weight: bold;
            color: #e2e8f0;
        }

        /* Global overlay + modal for onboarding / 6-info */
        .info-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .info-modal {
            background: #000;
            color: #fff;
            padding: 20px 22px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            max-width: 420px;
            width: 92%;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .info-modal p {
            margin: 10px 0 18px;
            font-size: 16px;
            line-height: 1.3;
        }

        .info-modal .ok-btn {
            padding: 10px 18px;
            background: #fff;
            color: #000;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }

        /* Roll button glow when modal active */
        .glow {
            box-shadow: 0 0 18px 6px rgba(255, 255, 255, 0.08), 0 0 40px 8px rgba(255, 255, 0, 0.18) !important;
            animation: pulseGlow 1.6s infinite;
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.04), 0 0 20px rgba(255, 255, 0, 0.08);
            }

            50% {
                box-shadow: 0 0 22px rgba(255, 255, 255, 0.06), 0 0 48px rgba(255, 255, 0, 0.22);
            }

            100% {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.04), 0 0 20px rgba(255, 255, 0, 0.08);
            }
        }

        /* Entry arrows container positioned inside outer-box */
        .entry-arrow {
            position: absolute;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1200;
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.6));
            transform-origin: center;
            animation: arrowFloat 1.6s ease-in-out infinite;
        }

        .entry-arrow svg {
            width: 100%;
            height: 100%;
        }

        @keyframes arrowFloat {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-6px);
            }

            100% {
                transform: translateY(0);
            }
        }

        #dice-face {
            margin: 10px 0;
            display: inline-block;
        }

        /* 3D Dice Cube */
        .cube {
            width: 80px;
            height: 80px;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(0deg) rotateY(0deg);
            transition: transform 2s cubic-bezier(0.25, 1.5, 0.5, 1);
            cursor: pointer;
            margin: 0 auto;
        }

        .face {
            position: absolute;
            width: 80px;
            height: 80px;
            background: white;
            border: 2px solid #2d3748;
            border-radius: 12px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            box-sizing: border-box;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .dot {
            width: 12px;
            height: 12px;
            background: #2d3748;
            border-radius: 50%;
            justify-self: center;
            align-self: center;
        }

        /* Positioning each face */
        .front {
            transform: rotateY(0deg) translateZ(40px);
        }

        .back {
            transform: rotateY(180deg) translateZ(40px);
        }

        .right {
            transform: rotateY(90deg) translateZ(40px);
        }

        .left {
            transform: rotateY(-90deg) translateZ(40px);
        }

        .top {
            transform: rotateX(90deg) translateZ(40px);
        }

        .bottom {
            transform: rotateX(-90deg) translateZ(40px);
        }

        #current-turn {
            font-size: 20px;
            font-weight: bold;
            margin-top: 10px;
            color: #e2e8f0;
        }

        #wall-controls {
            margin-top: 10px;
            text-align: center;
            width: 100%;
        }

        #place-wall-btn {
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            background: linear-gradient(135deg, #FF9800, #e68900);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s;
            width: 100%;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        #place-wall-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.4);
        }

        #place-wall-btn:disabled {
            background: #718096;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }

        #wall-stacks {
            position: absolute;
            bottom: 0%;
            right: 2%;
            display: flex;
            gap: 1vw;
            justify-content: center;
            align-items: flex-end;
            z-index: 5;
        }

        .wall-block {
            width: clamp(20px, 5.1vw, 38px);
            height: clamp(10px, 1.5vw, 15px);
            border: clamp(1px, 0.3vw, 2px) solid rgba(0, 0, 0, 0.7);
        }

        .wall-stack-column {
            display: grid;
            grid-template-rows: repeat(3, clamp(6px, 1.1vw, 12px));
            row-gap: clamp(4px, 0.6vw, 8px);
            align-items: end;
        }

        .wall-overlay {
            position: absolute;
            inset: 2px;
            pointer-events: none;
            animation: wallPlacement 1.5s ease-out;
        }

        @keyframes wallPlacement {
            0% {
                transform: scale(3.5);
                opacity: 0;
            }

            50% {
                transform: scale(2.5);
                opacity: 0.12;
            }

            70% {
                transform: scale(1.7);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        #win-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .win-card {
            background: linear-gradient(135deg, #1a202c, #2d3748);
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            width: 90%;
        }

        #win-text {
            font-size: 26px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }

        #reset-btn {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        #reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        /* Color Selection Screen */
        #color-selection {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .selection-card {
            background: linear-gradient(135deg, #1a202c, #2d3748);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .selection-title {
            font-size: 28px;
            margin-bottom: 30px;
            color: #fff;
            font-weight: 600;
        }

        .color-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .color-option {
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            font-size: 18px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .color-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.4);
        }

        .color-option.selected {
            transform: scale(1.05);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.8), 0 0 0 6px currentColor;
        }

        #start-game-btn {
            padding: 14px 40px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
        }

        #start-game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(76, 175, 80, 0.4);
        }

        /* Game header with restart button */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 10px;
        }

        .game-title {
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        #restart-game-btn {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #e53e3e, #c53030);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(229, 62, 62, 0.3);
        }

        #restart-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(229, 62, 62, 0.4);
        }

        #view {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #dae53e, #aac530);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(228, 252, 17, 0.3);
        }

        #view:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(214, 218, 10, 0.4);
        }

        #set {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #3ee576, #30c530);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(83, 252, 17, 0.3);
        }

        #set:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(17, 218, 10, 0.4);
        }

        /* Mobile-specific styles */
        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .mobile-controls-top {
            display: none;
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            margin-top: -50px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .mobile-controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
        }

        .mobile-controls-top-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
        }

        .mobile-dice-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .mobile-buttons-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-top-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-top-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Mobile Navbar */
        .mobile-navbar {
            display: none;
            width: 100%;
            background: linear-gradient(135deg, #f9d423 0%, #ff4e50 100%);
            color: #1a202c;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            box-sizing: border-box;
        }

        .mobile-navbar-title {
            font-weight: 800;
            font-size: 18px;
            text-transform: lowercase;
            letter-spacing: 0.5px;
        }

        #restart-game-btn-nav {
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            background: #CF3535;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        /* subtle 10px gaps between mobile sections */
        .mobile-gap {
            height: 10px;
        }

        /* Hide non-essential buttons on mobile to reduce clutter */
        /* Keep View Rule Book and Settings visible; move Restart to navbar */
        #restart-game-btn-mobile {
            display: none !important;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }

            .board-container {
                max-width: 90vw;
            }

            .controls-container {
                display: none;
            }

            .mobile-controls {
                display: flex;
                flex-direction: column;
            }

            .mobile-controls-top {
                display: flex;
                flex-direction: column;
            }

            .outer-box {
                width: 100%;
                max-width: 90vw;
            }

            .cube {
                width: 60px;
                height: 60px;
            }

            .face {
                width: 60px;
                height: 60px;
            }

            .dot {
                width: 8px;
                height: 8px;
            }

            .front {
                transform: rotateY(0deg) translateZ(30px);
            }

            .back {
                transform: rotateY(180deg) translateZ(30px);
            }

            .right {
                transform: rotateY(90deg) translateZ(30px);
            }

            .left {
                transform: rotateY(-90deg) translateZ(30px);
            }

            .top {
                transform: rotateX(90deg) translateZ(30px);
            }

            .bottom {
                transform: rotateX(-90deg) translateZ(30px);
            }

            .game-header {
                flex-direction: column;
                gap: 15px;
            }

            .game-title {
                font-size: 24px;
            }

            #restart-game-btn,
            #view,
            #set {
                padding: 8px 16px;
                font-size: 14px;
            }
        }

        @media (max-width: 768px) {
            .mobile-controls-grid {
                grid-template-columns: 1fr;
            }

            .mobile-controls-top-grid {
                grid-template-columns: 1fr;
            }

            /* Make the board larger on tablets / small laptops but keep small side gaps */
            .outer-box {
                width: calc(100% - 24px);
                max-width: calc(820px - 24px);
                margin: 0 12px;
            }

            .board-container {
                width: calc(100% - 24px);
                max-width: calc(820px - 24px);
                margin: 0 12px;
            }

            .grid-container {
                gap: 0.5vw;
            }

            .cube {
                width: 50px;
                height: 50px;
            }

            .face {
                width: 50px;
                height: 50px;
            }

            .dot {
                width: 6px;
                height: 6px;
            }

            .front {
                transform: rotateY(0deg) translateZ(25px);
            }

            .back {
                transform: rotateY(180deg) translateZ(25px);
            }

            .right {
                transform: rotateY(90deg) translateZ(25px);
            }

            .left {
                transform: rotateY(-90deg) translateZ(25px);
            }

            .top {
                transform: rotateX(90deg) translateZ(25px);
            }

            .bottom {
                transform: rotateX(-90deg) translateZ(25px);
            }

            #roll-btn,
            #place-wall-btn {
                padding: 12px 20px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {

            html,
            body {
                height: auto;
                min-height: 100dvh;
                overflow-y: auto !important;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                margin: 0;
                padding: 0;
            }

            .mobile-navbar {
                display: flex;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1000;
                margin: 0;
                padding: 10px 14px;
                width: 100%;
                box-sizing: border-box;
            }

            .mobile-controls-top {
                margin-top: 60px;
            }

            .game-area {
                margin-top: 10px;
            }

            .mobile-controls {
                margin-top: 10px;
            }

            /* Put View Rule Book and Settings on one line - equal width */
            .mobile-top-right {
                display: flex;
                flex-direction: row;
                align-items: stretch;
                justify-content: flex-end;
                gap: 10px;
                width: 100%;
            }

            /* Hide Restart button in mobile-top-right on small screens */
            #restart-game-btn-mobile {
                display: none;
            }

            #view-mobile,
            #set-mobile {
                flex: 1 1 0;
                min-width: 0;
                box-sizing: border-box;
                padding: 7px 12px !important;
                width: auto;
            }

            .mobile-top-right a {
                flex: 1 1 0;
                min-width: 0;
                box-sizing: border-box;
                display: flex;
            }

            .mobile-top-right a button {
                padding: 7px 12px !important;
                width: 100%;
                flex: 1;
            }

            .color-options {
                grid-template-columns: 1fr;
            }

            .selection-card {
                padding: 25px;
            }

            .selection-title {
                font-size: 22px;
            }

            .game-title {
                font-size: 20px;
            }

            /* Make the board take almost the full phone width: reduce side gaps to 2px */
            .outer-box {
                width: calc(100% - 4px);
                max-width: 820px;
                margin: 0 2px;
            }

            .board-container {
                width: calc(100% - 4px);
                max-width: 820px;
                margin: 0 2px;
            }

            .grid-container {
                gap: 0.4vw;
            }

            .location-icon {
                width: 12px;
                height: 12px;
            }

            /* Move top location icon down a bit in mobile view */
            .grid-item[data-r="0"][data-c="8"] .location-icon {
                top: 80%;
            }

            /* Move bottom location icon up a bit in mobile view */
            .grid-item[data-r="13"][data-c="8"] .location-icon {
                top: 20%;
            }

            /* Move left location icon to the right a bit in mobile view */
            .grid-item[data-r="7"][data-c="0"] .location-icon {
                left: 85%;
            }

            /* Move right location icon to the left a bit in mobile view */
            .grid-item[data-r="7"][data-c="16"] .location-icon {
                left: 15%;
            }

            .goti {
                width: 24px;
                height: 24px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), 0 0 0 2px rgba(255, 255, 255, 0.2);
            }

            .wall-block {
                width: clamp(18px, 4.6vw, 34px);
                height: clamp(8px, 1.2vw, 12px);
            }

            .entry-arrow {
                animation: none;
            }

            /* Larger dice on very small phones for visibility */
            .cube {
                width: 60px;
                height: 60px;
            }

            .face {
                width: 60px;
                height: 60px;
            }

            .dot {
                width: 8px;
                height: 8px;
            }

            .front {
                transform: rotateY(0deg) translateZ(20px);
            }

            .back {
                transform: rotateY(180deg) translateZ(20px);
            }

            .right {
                transform: rotateY(90deg) translateZ(20px);
            }

            .left {
                transform: rotateY(-90deg) translateZ(20px);
            }

            .top {
                transform: rotateX(90deg) translateZ(20px);
            }

            .bottom {
                transform: rotateX(-90deg) translateZ(20px);
            }

            #roll-btn,
            #place-wall-btn {
                padding: 10px 16px;
                font-size: 14px;
            }

            #current-turn,
            #dice-result {
                font-size: 16px;
            }
        }

        /* Settings Modal Styles */
        #settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .settings-card {
            background: linear-gradient(135deg, #1a202c, #2d3748);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-title {
            font-size: 24px;
            margin-bottom: 25px;
            color: #fff;
            font-weight: 600;
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            transition: all 0.3s;
        }

        .settings-option:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .option-label {
            font-size: 18px;
            color: #fff;
            font-weight: 500;
        }

        .sound-toggle {
            width: 60px;
            height: 30px;
            background: #718096;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .sound-toggle.active {
            background: #4CAF50;
        }

        .sound-toggle::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .sound-toggle.active::after {
            transform: translateX(30px);
        }

        .sound-icon {
            font-size: 20px;
            margin-right: 10px;
        }

        .close-settings {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            width: 100%;
        }

        .close-settings:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        /* Update the existing set button style */
        #set {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #3ee576, #30c530);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(83, 252, 17, 0.3);
        }

        #set:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(17, 218, 10, 0.4);
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Mobile Navbar -->
        <div class="mobile-navbar">
            <div class="mobile-navbar-title">Deceptionist</div>
            <button id="restart-game-btn-nav">Restart Game</button>
        </div>
        <!-- Mobile Top Controls -->
        <div class="mobile-controls-top">
            <div class="mobile-controls-top-grid">
                <div class="mobile-top-left">
                    <div id="current-turn-mobile" style="text-align: center;">Current Turn: Yellow</div>
                    <div style="text-align: center;" id="you-are-mobile">You are: <strong
                            id="you-color-mobile">Yellow</strong></div>
                </div>
                <div class="mobile-top-right">
                    <button id="restart-game-btn-mobile">Restart Game</button>
                    <button id="set-mobile">‚öôÔ∏èSettings</button>
                    <a href="./rule_book.html" target="_blank"><button id="view-mobile">See Rules</button></a>
                </div>
            </div>
        </div>

        <div class="game-area">
            <div class="board-container">
                <div class="outer-box">
                    <div class="grid-container" id="grid-container">
                        <!-- Grid will be generated by JavaScript -->
                        <div id="wall-stacks"></div>
                    </div>
                </div>
            </div>

            <div class="controls-container">
                <div id="dice-container">
                    <div id="you-are">You are: <strong id="you-color">Yellow</strong></div>
                    <button id="roll-btn">Roll Dice</button>
                    <div id="dice-face">
                        <div class="cube" id="dice">
                            <!-- 1 -->
                            <div class="face front">
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                            </div>
                            <!-- 6 -->
                            <div class="face back">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:1; grid-row:2;"></div>
                                <div class="dot" style="grid-column:3; grid-row:2;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 3 -->
                            <div class="face right">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 4 -->
                            <div class="face left">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 5 -->
                            <div class="face top">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 2 -->
                            <div class="face bottom">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                        </div>
                    </div>
                    <div id="current-turn">Current Turn: Yellow</div>
                    <div id="dice-result" style="font-size: 18px; font-weight: bold; margin-top: -2px; color: #e2e8f0;">
                        Rolled:
                    </div>
                    <div id="wall-controls">
                        <div id="walls-left">Walls Left: 3</div>
                        <button id="place-wall-btn" disabled>Place Wall</button>
                        <br><br>
                        <button id="restart-game-btn">Restart Game</button>
                        <br><br>
                        <a href="./rule_book.html" target="_blank"><button id="view">View Rule Book</button></a>
                        <br><br>
                        <button id="set">‚öôÔ∏èSettings</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mobile Bottom Controls -->
        <div class="mobile-controls">
            <div class="mobile-controls-grid">
                <div class="mobile-dice-section">
                    <div id="dice-face-mobile">
                        <div class="cube" id="dice-mobile">
                            <!-- 1 -->
                            <div class="face front">
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                            </div>
                            <!-- 6 -->
                            <div class="face back">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:1; grid-row:2;"></div>
                                <div class="dot" style="grid-column:3; grid-row:2;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 3 -->
                            <div class="face right">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 4 -->
                            <div class="face left">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 5 -->
                            <div class="face top">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:1;"></div>
                                <div class="dot" style="grid-column:2; grid-row:2;"></div>
                                <div class="dot" style="grid-column:1; grid-row:3;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                            <!-- 2 -->
                            <div class="face bottom">
                                <div class="dot" style="grid-column:1; grid-row:1;"></div>
                                <div class="dot" style="grid-column:3; grid-row:3;"></div>
                            </div>
                        </div>
                    </div>
                    <div id="dice-result-mobile"
                        style="font-size: 18px; font-weight: bold; margin-top: -2px; color: #e2e8f0;">
                        Rolled:
                    </div>
                </div>
                <div class="mobile-buttons-section">
                    <button id="roll-btn-mobile">Roll Dice</button>
                    <div id="walls-left-mobile">Walls Left: 3</div>
                    <button id="place-wall-btn-mobile" disabled>Place Wall</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="settings-card">
            <h2 class="settings-title">Game Settings</h2>

            <div class="settings-option">
                <div style="display: flex; align-items: center;">
                    <span class="sound-icon">üîä</span>
                    <span class="option-label">Sound</span>
                </div>
                <div class="sound-toggle active" id="sound-toggle"></div>
            </div>

            <button class="close-settings" id="close-settings">Close Settings</button>
        </div>
    </div>

    <!-- Onboarding Info Modal shown when user starts the game -->
    <div id="onboarding-overlay" class="info-overlay">
        <div class="info-modal" id="onboarding-modal">
            <p id="onboarding-text">You are <strong id="onboarding-color">Yellow</strong>. You have to escape from our
                opposite entry point. Click roll dice</p>
            <button class="ok-btn" id="onboarding-ok">OK</button>
        </div>
    </div>

    <!-- Six-info Modal shown when user rolls a 6 for the first time in a turn (explanation) -->
    <div id="six-overlay" class="info-overlay">
        <div class="info-modal" id="six-modal">
            <p>When ever 6 is come you have 2 mode: move token or place wall to block any other ‚Äî use it strategically.
            </p>
            <button class="ok-btn" id="six-ok">OK</button>
        </div>
    </div>

    <!-- Color Selection Screen -->
    <div id="color-selection">
        <div class="selection-card">
            <h2 class="selection-title">Choose Your Color</h2>
            <div class="color-options">
                <div class="color-option" data-color="yellow" style="background-color: #ffd500;">Yellow</div>
                <div class="color-option" data-color="green" style="background-color: #68DD00;">Green</div>
                <div class="color-option" data-color="blue" style="background-color: #3370ff;">Blue</div>
                <div class="color-option" data-color="red" style="background-color: #ff4d4d;">Red</div>
            </div>
            <button id="start-game-btn">Start Game</button>
        </div>
    </div>

    <!-- Win Overlay -->
    <div id="win-overlay">
        <div class="win-card">
            <div id="win-text"></div>
            <button id="reset-btn">Play Again</button>
        </div>
    </div>

    <!-- Hidden audio elements for sound effects -->
    <audio id="dice-sound" preload="auto">
        <source src="dice.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="goti-move-sound" preload="auto">
        <source src="goti_move.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="win-sound" preload="auto">
        <source src="win.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="lose-sound" preload="auto">
        <source src="lose.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="wall-sound" preload="auto">
        <source src="wall.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script>
        // Game variables
        const rows = 14;
        const cols = 17;
        const pinSVG = '<svg viewBox="0 0 24 24" fill="white"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>';
        const positionToElement = {};

        // Game state
        const startYellow = [0, 8];
        const startGreen = [7, 0];
        const startBlue = [7, 16];
        const startRed = [13, 8];
        const centerYellow = [0, 8];
        const centerGreen = [7, 0];
        const centerBlue = [7, 16];
        const centerRed = [13, 8];

        let paths = null;
        let gotis = {};
        const allColors = ['yellow', 'green', 'blue', 'red'];
        let activeColors = ['yellow', 'green', 'blue', 'red'];
        let turnOrder = activeColors.slice();
        let currentTurn = 0;
        let turnSeq = 0;
        let currentPositions = { yellow: 0, green: 0, blue: 0, red: 0 };
        let isUnlocked = { yellow: false, green: false, blue: false, red: false };
        let forwardHighlighted = null;
        let backwardHighlighted = null;
        let rollValue = 0;
        let moveSteps = 0;
        let canPlaceWallThisTurn = false;
        let hasPlacedWallThisTurn = false;
        let reachableTargets = new Set();
        let bfsParents = new Map();
        let bfsStartKey = '';
        let hasRolledThisTurn = false;
        let placingWall = false;
        const walls = { yellow: [], green: [], blue: [], red: [] };
        const wallCellToOwner = new Map();
        const wallsPerColorLimit = 3;
        const wallCounts = { yellow: 3, green: 3, blue: 3, red: 3 };
        let completed = { yellow: false, green: false, blue: false, red: false };
        let finishOrder = [];
        let currentMode = '1v3';
        let humanColor = 'yellow';
        let botColors = new Set(['green', 'blue', 'red']);

        // Game state management
        let gameActive = true;

        // Sound settings
        let soundEnabled = true;

        // DOM Elements
        const gridContainer = document.getElementById('grid-container');
        const rollBtn = document.getElementById('roll-btn');
        const diceFace = document.getElementById('dice-face');
        const currentTurnEl = document.getElementById('current-turn');
        const placeWallBtn = document.getElementById('place-wall-btn');
        const wallsLeftEl = document.getElementById('walls-left');
        const winOverlay = document.getElementById('win-overlay');
        const winText = document.getElementById('win-text');
        const resetBtn = document.getElementById('reset-btn');
        const colorSelection = document.getElementById('color-selection');
        const colorOptions = document.querySelectorAll('.color-option');
        const startGameBtn = document.getElementById('start-game-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const settingsModal = document.getElementById('settings-modal');
        const settingsBtn = document.getElementById('set');
        const closeSettingsBtn = document.getElementById('close-settings');
        const soundToggle = document.getElementById('sound-toggle');

        // Mobile DOM Elements
        const rollBtnMobile = document.getElementById('roll-btn-mobile');
        const placeWallBtnMobile = document.getElementById('place-wall-btn-mobile');
        const wallsLeftElMobile = document.getElementById('walls-left-mobile');
        const currentTurnElMobile = document.getElementById('current-turn-mobile');
        const youColorElMobile = document.getElementById('you-color-mobile');
        const youAreElMobile = document.getElementById('you-are-mobile');
        const diceResultMobile = document.getElementById('dice-result-mobile');
        const restartGameBtnMobile = document.getElementById('restart-game-btn-mobile');
        const viewBtnMobile = document.getElementById('view-mobile');
        const settingsBtnMobile = document.getElementById('set-mobile');
        const diceMobile = document.getElementById('dice-mobile');
        const dice = document.getElementById('dice');
        const restartGameBtnNav = document.getElementById('restart-game-btn-nav');

        // Audio elements
        const diceSound = document.getElementById('dice-sound');
        const gotiMoveSound = document.getElementById('goti-move-sound');
        const winSound = document.getElementById('win-sound');
        const loseSound = document.getElementById('lose-sound');
        const wallSound = document.getElementById('wall-sound');

        // Initialize game
        function initGame() {
            createBoard();
            createGotis();
            setupEventListeners();
            updateWallsLeftUI();
            renderWallStacks();
            updateRollButtonState();
            loadSoundSetting();
            // Do NOT load saved game state on refresh ‚Äî start fresh every load
            // Remove any persisted state so refresh always restarts the game
            try { localStorage.removeItem('deceptionist_game_state'); } catch (e) { }
        }

        /* Modal helpers for onboarding and six-info */
        const onboardingOverlay = document.getElementById('onboarding-overlay');
        const onboardingOk = document.getElementById('onboarding-ok');
        const onboardingTextEl = document.getElementById('onboarding-text');

        const sixOverlay = document.getElementById('six-overlay');
        const sixOk = document.getElementById('six-ok');

        let botSpeedMultiplier = 1; // default faster bots (2x)
        // track how many 6's the human player has rolled; only show modal on 2nd 6
        const humanSixCount = { yellow: 0, green: 0, blue: 0, red: 0 };
        const sixModalShownFor = { yellow: false, green: false, blue: false, red: false };
        let shouldSpeedOnSixOk = false;

        function showOnboardingFor(color) {
            const colorName = color.charAt(0).toUpperCase() + color.slice(1);
            const oppositeMap = { yellow: 'Red', red: 'Yellow', green: 'Blue', blue: 'Green' };
            const opposite = oppositeMap[color] || '';
            const onboardingText = document.getElementById('onboarding-text');
            if (onboardingText) onboardingText.innerHTML = `You are <strong>${colorName}</strong>. You have to escape from <strong>${opposite}</strong>.`;
            onboardingOverlay.style.display = 'flex';
            // add glow to roll buttons to draw attention
            rollBtn.classList.add('glow');
            rollBtnMobile.classList.add('glow');
        }

        function hideOnboarding() {
            onboardingOverlay.style.display = 'none';
            rollBtn.classList.remove('glow');
            rollBtnMobile.classList.remove('glow');
        }

        function showSixInfo() {
            sixOverlay.style.display = 'flex';
            // dark overlay already blocks page; highlight place wall button
            placeWallBtn.classList.add('glow');
            placeWallBtnMobile.classList.add('glow');
        }

        function hideSixInfo() {
            sixOverlay.style.display = 'none';
            placeWallBtn.classList.remove('glow');
            placeWallBtnMobile.classList.remove('glow');
        }

        onboardingOk?.addEventListener('click', () => {
            hideOnboarding();
            // start the game normally (unpause)
            applyMode(currentMode);
            updateAllGotiSizes();
            updateRollButtonState();
            botTakeTurnIfNeeded();
        });

        sixOk?.addEventListener('click', () => {
            // hide and set bot speed 2x only if flagged
            hideSixInfo();
            if (shouldSpeedOnSixOk) {
                botSpeedMultiplier = 2;
                shouldSpeedOnSixOk = false;
            }
        });

        // Create the game board
        function createBoard() {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const box = document.createElement('div');

                    // Skip cells that are not part of the playable board
                    if (shouldSkipCell(r, c)) {
                        gridContainer.appendChild(box);
                        continue;
                    }

                    // Create special colored cells
                    if (isSpecialCell(r, c)) {
                        createSpecialCell(box, r, c);
                        continue;
                    }

                    // Create regular grid cell
                    box.className = 'grid-item';
                    box.dataset.r = r.toString();
                    box.dataset.c = c.toString();
                    gridContainer.appendChild(box);
                }
            }

            // Cache base styles for highlighting
            document.querySelectorAll('.grid-item').forEach(box => {
                const r = parseInt(box.dataset.r);
                const c = parseInt(box.dataset.c);
                positionToElement[`${r}-${c}`] = box;

                if (!box.dataset.baseBorder) box.dataset.baseBorder = box.style.border || '2px solid black';
                if (!box.dataset.baseBg) box.dataset.baseBg = box.style.background || '';
            });

            // Compute paths
            paths = {
                yellow: computePath(startYellow, centerRed),
                red: computePath(startRed, centerYellow),
                green: computePath(startGreen, centerBlue),
                blue: computePath(startBlue, centerGreen)
            };
        }

        // Helper functions for board creation
        function shouldSkipCell(r, c) {
            // Define which cells to skip based on row
            const skipPatterns = {
                0: (c) => c < 4 || c >= 11,
                1: (c) => ![4, 7, 10, 11, 12].includes(c),
                2: (c) => ![4, 5, 7, 10, 12].includes(c),
                3: (c) => ![5, 7, 10, 12, 13].includes(c),
                4: (c) => ![1, 2, 3, 4, 5, 6, 7, 8, 10, 13].includes(c),
                5: (c) => ![0, 1, 2, 4, 6, 8, 9, 10, 12, 13, 14, 15, 16].includes(c),
                6: (c) => ![0, 2, 4, 6, 10, 12, 14, 16].includes(c),
                7: (c) => ![0, 2, 4, 6, 10, 12, 14, 16].includes(c),
                8: (c) => ![0, 2, 4, 6, 8, 9, 10, 12, 13, 14, 16].includes(c),
                9: (c) => ![0, 2, 4, 6, 8, 12, 14, 16].includes(c),
                10: (c) => ![0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16].includes(c),
                11: (c) => ![1, 2, 5, 11].includes(c),
                12: (c) => ![2, 5, 11].includes(c),
                13: (c) => ![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].includes(c)
            };

            return skipPatterns[r] ? skipPatterns[r](c) : false;
        }

        function isSpecialCell(r, c) {
            // Yellow home cells
            if (r === 0 && [7, 8, 9].includes(c)) return true;

            // Green home cells
            if ((r === 6 || r === 7 || r === 8) && c === 0) return true;

            // Blue home cells
            if ((r === 6 || r === 7 || r === 8) && c === cols - 1) return true;

            // Red home cells
            if (r === rows - 1 && (c === 7 || c === 8 || c === 9)) return true;

            return false;
        }

        function createSpecialCell(box, r, c) {
            box.className = 'grid-item';
            box.dataset.r = r.toString();
            box.dataset.c = c.toString();

            // Yellow cells
            if (r === 0 && [8].includes(c)) {
                box.style.background = 'yellow';
                box.style.border = '3px solid black';
                if (c === 8) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(180deg)';
                    box.appendChild(icon);
                }
            }
            // Green cells
            else if ((r === 7) && c === 0) {
                box.style.background = '#68DD00';
                box.style.border = '3px solid black';
                if (r === 7) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(90deg)';
                    box.appendChild(icon);
                }
            }
            // Blue cells
            else if ((r === 7) && c === cols - 1) {
                box.style.background = 'blue';
                box.style.border = '3px solid black';
                if (r === 7) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(270deg)';
                    box.appendChild(icon);
                }
            }
            // Red cells
            else if (r === rows - 1 && (c === 8)) {
                box.style.background = 'red';
                box.style.border = '3px solid black';
                if (c === 8) {
                    box.classList.add('has-location-icon');
                    const icon = document.createElement('div');
                    icon.className = 'location-icon';
                    icon.innerHTML = pinSVG;
                    icon.style.transform = 'translate(-50%, -50%) rotate(0deg)';
                    box.appendChild(icon);
                }
            }

            gridContainer.appendChild(box);
        }

        // Create game pieces
        function createGotis() {
            allColors.forEach(color => {
                let startPos;
                if (color === 'yellow') startPos = [0, 8];
                else if (color === 'green') startPos = [7, 0];
                else if (color === 'blue') startPos = [7, 16];
                else startPos = [13, 8];

                const startKey = `${startPos[0]}-${startPos[1]}`;
                const startBox = positionToElement[startKey];
                const goti = document.createElement('div');
                goti.className = `goti ${color}`;

                // Set color
                if (color === 'yellow') goti.style.backgroundColor = 'yellow';
                else if (color === 'green') goti.style.backgroundColor = '#68DD00';
                else if (color === 'blue') goti.style.backgroundColor = 'blue';
                else goti.style.backgroundColor = 'red';

                // Position initially over each color's wall stack (locked state)
                goti.style.position = 'absolute';
                document.querySelector('.outer-box').appendChild(goti);
                gotis[color] = { goti: goti, r: startPos[0], c: startPos[1] };
                currentPositions[color] = 0;
                // show locked token above its wall stack
                placeGotiAtHome(color);

                goti.style.position = 'absolute';
                document.querySelector('.outer-box').appendChild(goti);
                gotis[color] = { goti: goti, r: startPos[0], c: startPos[1] };
                currentPositions[color] = 0;
            });
            // render entry arrows
            renderEntryArrows();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Roll button
            rollBtn.addEventListener('click', handleRoll);
            rollBtnMobile.addEventListener('click', handleRoll);

            // Dice click handlers - click on dice to roll
            if (dice) {
                dice.addEventListener('click', handleRoll);
                dice.style.cursor = 'pointer';
            }
            if (diceMobile) {
                diceMobile.addEventListener('click', handleRoll);
                diceMobile.style.cursor = 'pointer';
            }

            // Place wall button
            placeWallBtn.addEventListener('click', toggleWallPlacement);
            placeWallBtnMobile.addEventListener('click', toggleWallPlacement);

            // Reset button -> clear saved state and navigate back to index.html (full restart)
            resetBtn.addEventListener('click', () => {
                localStorage.removeItem('deceptionist_game_state');
                window.location.href = 'deceptionist.html';
            });

            // Restart game button
            restartGameBtn.addEventListener('click', () => {
                localStorage.removeItem('deceptionist_game_state');
                window.location.reload();
            });
            restartGameBtnMobile.addEventListener('click', () => {
                localStorage.removeItem('deceptionist_game_state');
                window.location.reload();
            });
            if (restartGameBtnNav) {
                restartGameBtnNav.addEventListener('click', () => {
                    localStorage.removeItem('deceptionist_game_state');
                    window.location.reload();
                });
            }

            // Color selection
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    humanColor = option.dataset.color;
                    const youColorEl = document.getElementById('you-color');
                    const youColorElMobile = document.getElementById('you-color-mobile');
                    if (youColorEl) youColorEl.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
                    if (youColorElMobile) youColorElMobile.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
                });
            });

            // Start game button
            startGameBtn.addEventListener('click', startGame);

            // Grid cell clicks
            document.querySelectorAll('.grid-item').forEach(box => {
                box.addEventListener('click', handleCellClick);
            });

            // Settings button
            settingsBtn.addEventListener('click', openSettings);
            settingsBtnMobile.addEventListener('click', openSettings);
            closeSettingsBtn.addEventListener('click', closeSettings);
            soundToggle.addEventListener('click', toggleSound);

            // Close settings modal when clicking outside
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) closeSettings();
            });
        }

        // Start the game after color selection
        function startGame() {
            // hide color selection UI, but show onboarding modal first
            colorSelection.style.display = 'none';
            // show onboarding overlay with the chosen human color and pause until OK
            showOnboardingFor(humanColor);
        }

        // Apply mode settings
        function applyMode(mode) {
            // Set human color based on selection
            // All other colors become bots
            botColors = new Set();
            allColors.forEach(color => {
                if (color !== humanColor) {
                    botColors.add(color);
                }
            });

            // Update active colors
            activeColors = allColors.slice();
            turnOrder = activeColors.slice();

            // Make sure human color is first in turn order
            const humanIndex = turnOrder.indexOf(humanColor);
            if (humanIndex > 0) {
                turnOrder.splice(humanIndex, 1);
                turnOrder.unshift(humanColor);
                currentTurn = 0;
            }

            updateVisibility();
            updateTurnDisplay();
        }

        // Update turn display
        function updateTurnDisplay() {
            const color = turnOrder[currentTurn];
            const displayText = `Current Turn: ${color.charAt(0).toUpperCase() + color.slice(1)}`;
            currentTurnEl.textContent = displayText;
            currentTurnElMobile.textContent = displayText;
        }

        // Update piece visibility based on active colors
        function updateVisibility() {
            allColors.forEach(c => {
                const el = gotis[c]?.goti;
                if (!el) return;
                el.style.display = activeColors.includes(c) ? 'block' : 'none';
            });
        }

        // Handle roll button click
        function handleRoll() {
            const color = turnOrder[currentTurn];

            if (botColors.has(color)) {
                return; // Ignore if it's a bot's turn
            }

            if (hasRolledThisTurn) {
                return; // Only one roll per turn
            }

            if (!gameActive) {
                return; // Game is not active
            }

            hasRolledThisTurn = true;
            clearAllHighlights();
            rollValue = Math.floor(Math.random() * 6) + 1;

            // Play dice sound
            playDiceSound();

            showDice(rollValue);
            moveSteps = rollValue;
            canPlaceWallThisTurn = (rollValue === 6);

            // Enable wall placement button if applicable
            placeWallBtn.disabled = !canPlaceWallThisTurn || wallCounts[color] <= 0;
            placeWallBtnMobile.disabled = !canPlaceWallThisTurn || wallCounts[color] <= 0;

            const gotiData = gotis[color];

            // If human rolled a 6, handle special modal logic: show modal only on second 6 for this color
            if (!botColors.has(color) && rollValue === 6) {
                humanSixCount[color] = (humanSixCount[color] || 0) + 1;
                // show modal only on the second 6 and only once per color
                if (humanSixCount[color] === 2 && !sixModalShownFor[color]) {
                    sixModalShownFor[color] = true;
                    // mark that on OK we should speed up bots
                    shouldSpeedOnSixOk = true;
                    showSixInfo();
                    // after OK, process the roll (sixOk listener will set speed if flagged)
                    const onceHandler = () => {
                        sixOk.removeEventListener('click', onceHandler);
                        processRoll(color, gotiData);
                    };
                    sixOk.addEventListener('click', onceHandler);
                    // ensure the dice animation completes as well ‚Äî we still call showDice with callback
                    showDice(rollValue, () => { });
                } else {
                    // Not the second 6 (either first or subsequent) ‚Äî just process normally
                    showDice(rollValue, () => processRoll(color, gotiData));
                }
            } else {
                // Process roll after animation; showDice handles transitionend and a fallback timeout
                showDice(rollValue, () => processRoll(color, gotiData));
            }
        }

        // Process the roll result
        function processRoll(color, gotiData) {
            // Locked/unlock logic: must roll 6 to enter the board
            if (!isUnlocked[color]) {
                if (rollValue === 6) {
                    isUnlocked[color] = true;
                    placeGotiAtCell(color, gotiData.r, gotiData.c);
                    relayoutAllOccupants();
                    canPlaceWallThisTurn = false;
                    placeWallBtn.disabled = true;
                    placeWallBtnMobile.disabled = true;

                    // Auto-advance turn
                    nextTurn();
                    return;
                } else {
                    // Auto-advance turn when locked and no 6 rolled
                    nextTurn();
                    return;
                }
            }

            // Calculate reachable cells
            const { targets, parents, startKey } = bfsReachableExact(gotiData.r, gotiData.c, moveSteps, color);
            reachableTargets = targets;
            bfsParents = parents;
            bfsStartKey = startKey;

            // Highlight reachable cells
            const tint = colorTint(color);
            reachableTargets.forEach(key => {
                if (key === startKey) return;
                const el = positionToElement[key];
                if (el) {
                    el.style.background = tint.bg;
                    el.style.border = tint.border;
                }
            });

            // If no moves available, auto-advance turn
            if (!reachableTargets.size || (reachableTargets.size === 1 && reachableTargets.has(startKey))) {
                nextTurn();
            }
        }

        // Handle cell click
        function handleCellClick(e) {
            const box = e.currentTarget;

            if (!gameActive) {
                return; // Game is not active
            }

            // Wall placement mode
            if (placingWall) {
                const color = turnOrder[currentTurn];
                if (botColors.has(color)) return;

                const r = parseInt(box.dataset.r);
                const c = parseInt(box.dataset.c);
                const placed = placeWall(color, r, c);

                if (placed) {
                    hasPlacedWallThisTurn = true;
                    canPlaceWallThisTurn = false;
                    placeWallBtn.disabled = true;
                    placeWallBtnMobile.disabled = true;
                    clearAllHighlights();
                    exitWallPlacementMode();
                    nextTurn();
                }
                return;
            }

            // Movement mode
            const color = turnOrder[currentTurn];
            if (botColors.has(color)) return;

            const key = `${box.dataset.r}-${box.dataset.c}`;
            if (reachableTargets.has(key) && key !== bfsStartKey) {
                // If player chooses to move, they forfeit wall placement this turn
                canPlaceWallThisTurn = false;
                placeWallBtn.disabled = true;
                placeWallBtnMobile.disabled = true;

                if (placingWall) exitWallPlacementMode();

                // Move the piece
                moveToTargetKey(color, key);
            }
        }

        // Move piece to target cell
        function moveToTargetKey(color, targetKey) {
            const gotiData = gotis[color];
            const pathKeys = [];
            let cur = targetKey;
            pathKeys.push(cur);

            while (cur !== bfsStartKey) {
                const p = bfsParents.get(cur);
                if (!p) break;
                cur = p;
                pathKeys.push(cur);
            }

            pathKeys.reverse();
            let stepIndex = 1; // skip current cell

            function stepAnim() {
                if (stepIndex < pathKeys.length) {
                    const [r, c] = pathKeys[stepIndex].split('-').map(Number);
                    const cellWidth = 100 / cols;
                    const cellHeight = 100 / rows;
                    gotiData.goti.style.left = (c * cellWidth + cellWidth / 2) + '%';
                    gotiData.goti.style.top = (r * cellHeight + cellHeight / 2) + '%';
                    gotiData.r = r;
                    gotiData.c = c;
                    stepIndex++;

                    // speed up bot movement when bots are faster
                    const delay = botColors.has(color) ? Math.max(80, 450 / Math.max(1, botSpeedMultiplier)) : 450;
                    setTimeout(stepAnim, delay);
                } else {
                    // Done moving
                    // Stop movement sound
                    stopGotiMoveSound();

                    relayoutAllOccupants();
                    clearAllHighlights();

                    // Check if reached goal
                    const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
                    const [gr, gc] = goals[color];
                    if (gotiData.r === gr && gotiData.c === gc) {
                        // persist before finishing
                        saveGameState();
                        showWin(color);
                    } else {
                        // persist the new position
                        saveGameState();
                        nextTurn();
                    }
                }
            }

            // Start movement sound once for the whole multi-step move
            playGotiMoveSound();

            stepAnim();
        }

        // Bot logic
        function botTakeTurnIfNeeded() {
            const color = turnOrder[currentTurn];
            const token = turnSeq;

            if (!botColors.has(color)) {
                return;
            }

            if (!gameActive) {
                return; // Game is not active
            }

            if (isAtGoal(color)) {
                nextTurn();
                return;
            }

            // Bot roll dice
            clearAllHighlights();
            rollValue = Math.floor(Math.random() * 6) + 1;
            moveSteps = rollValue;
            canPlaceWallThisTurn = (rollValue === 6);
            const gotiData = gotis[color];

            // Play dice sound for bot too
            playDiceSound();

            // Show dice with animation
            showDice(rollValue, () => {
                // Process bot roll after animation
                if (!isUnlocked[color]) {
                    if (rollValue === 6) {
                        isUnlocked[color] = true;
                        placeGotiAtCell(color, gotiData.r, gotiData.c);
                        relayoutAllOccupants();
                        canPlaceWallThisTurn = false;
                        nextTurn();
                        return;
                    } else {
                        nextTurn();
                        return;
                    }
                }

                const { targets, parents, startKey } = bfsReachableExact(gotiData.r, gotiData.c, moveSteps, color);
                reachableTargets = targets;
                bfsParents = parents;
                bfsStartKey = startKey;

                // Bot wall placement logic (simplified)
                // Bot wall placement logic (improved)
                if (rollValue === 6 && wallCounts[color] > 0 && isUnlocked[color] && Math.random() < 0.9) {
                    // Strategy: try to block an opponent's next step towards their goal.
                    const opponents = turnOrder.filter(c => c !== color && !completed[c]);
                    // Gather candidate block cells (prefer blocking immediate next step)
                    const blockCandidates = [];

                    for (const opp of opponents) {
                        // Skip opponents that are not unlocked (they can't move yet)
                        if (!isUnlocked[opp]) continue;
                        const oppPos = gotis[opp];
                        if (!oppPos) continue;
                        const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
                        const oppGoal = goals[opp];
                        const oppPath = computePath([oppPos.r, oppPos.c], oppGoal);
                        // If opponent has a next step, consider blocking that cell
                        if (oppPath && oppPath.length > 1) {
                            const nextStep = oppPath[1];
                            const key = `${nextStep[0]}-${nextStep[1]}`;
                            // Skip if there's already a wall, a location icon, or a goti occupying the cell
                            let occupied = false;
                            for (const col of allColors) {
                                const info = gotis[col];
                                if (!info) continue;
                                if (info.r === nextStep[0] && info.c === nextStep[1]) {
                                    occupied = true;
                                    break;
                                }
                            }
                            if (!occupied && !wallCellToOwner.has(key) && positionToElement[key] && !positionToElement[key].querySelector('.location-icon')) {
                                blockCandidates.push({ key, priority: 10, opp });
                            }
                        }
                    }

                    // If no direct next-step blocks, look for shared-path nodes to block multiple opponents
                    if (blockCandidates.length === 0) {
                        const pathCounts = {};
                        for (const opp of opponents) {
                            if (!isUnlocked[opp]) continue;
                            const oppPos = gotis[opp];
                            if (!oppPos) continue;
                            const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
                            const oppGoal = goals[opp];
                            const oppPath = computePath([oppPos.r, oppPos.c], oppGoal);
                            if (!oppPath) continue;
                            // consider first few steps of their path
                            for (let i = 1; i < Math.min(6, oppPath.length); i++) {
                                const k = `${oppPath[i][0]}-${oppPath[i][1]}`;
                                if (!positionToElement[k]) continue;
                                if (positionToElement[k].querySelector('.location-icon')) continue;
                                if (wallCellToOwner.has(k)) continue;
                                // don't consider cells currently occupied by any goti
                                let occ = false;
                                for (const col of allColors) {
                                    const info = gotis[col];
                                    if (!info) continue;
                                    if (info.r === oppPath[i][0] && info.c === oppPath[i][1]) { occ = true; break; }
                                }
                                if (occ) continue;
                                pathCounts[k] = (pathCounts[k] || 0) + 1;
                            }
                        }
                        // Turn pathCounts into candidates with priority based on how many paths cross the cell
                        for (const k in pathCounts) {
                            blockCandidates.push({ key: k, priority: 5 + pathCounts[k] });
                        }
                    }

                    // Remove any candidates that would block own path to goal
                    const ownGoal = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen }[color];
                    const ownPath = computePath([gotis[color].r, gotis[color].c], ownGoal) || [];
                    const ownPathKeys = new Set(ownPath.map(p => `${p[0]}-${p[1]}`));
                    const finalCandidates = blockCandidates.filter(c => !ownPathKeys.has(c.key));

                    // Try candidates in priority order
                    finalCandidates.sort((a, b) => b.priority - a.priority);
                    let placedWall = false;
                    for (const cand of finalCandidates) {
                        const [r, c] = cand.key.split('-').map(Number);
                        if (placeWall(color, r, c)) {
                            placedWall = true;
                            break;
                        }
                    }

                    // Fallback: random placement but prefer cells on our own forward path (but not start/home icons)
                    if (!placedWall) {
                        const keys = Object.keys(positionToElement);
                        const validKeys = keys.filter(k => {
                            if (wallCellToOwner.has(k)) return false;
                            const cell = positionToElement[k];
                            return cell && !cell.querySelector('.location-icon');
                        });
                        // prefer keys on opponent paths or own path
                        const preferred = validKeys.filter(k => ownPathKeys.has(k));
                        const pickPool = preferred.length ? preferred : validKeys;
                        if (pickPool.length > 0) {
                            const randomKey = pickPool[Math.floor(Math.random() * pickPool.length)];
                            const [r, c] = randomKey.split('-').map(Number);
                            if (placeWall(color, r, c)) {
                                placedWall = true;
                            }
                        }
                    }

                    if (placedWall) {
                        clearAllHighlights();
                        nextTurn();
                        return;
                    }
                }

                // Bot movement
                setTimeout(() => {
                    if (token !== turnSeq) return;

                    if (!gameActive) {
                        return; // Game is not active
                    }

                    const key = chooseBestTargetForBot(color);
                    if (key) {
                        moveToTargetKey(color, key);
                    } else {
                        nextTurn();
                    }
                }, 400 / Math.max(1, botSpeedMultiplier));
            });
        }

        // Choose best target for bot
        function chooseBestTargetForBot(color) {
            const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
            const goal = goals[color];
            // Score targets: prefer shorter distance to goal, prefer safety (far from opponents), avoid opponent walls
            let bestKey = null;
            let bestScore = Infinity;

            function manhattan(a, b) {
                return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
            }

            // compute opponent positions
            const opponents = turnOrder.filter(c => c !== color && !completed[c]);
            const opponentPositions = opponents.map(c => gotis[c]).filter(p => p);

            reachableTargets.forEach(key => {
                if (key === bfsStartKey) return;
                const [r, c] = key.split('-').map(Number);
                const pathToGoal = computePath([r, c], goal) || [];
                const len = Math.max(0, pathToGoal.length - 1);

                // safety: distance to nearest opponent
                let minOppDist = Infinity;
                for (const op of opponentPositions) {
                    if (!op) continue;
                    const d = manhattan([r, c], [op.r, op.c]);
                    if (d < minOppDist) minOppDist = d;
                }
                if (minOppDist === Infinity) minOppDist = 10;

                // walls nearby penalty (especially opponent walls)
                let wallPenalty = 0;
                for (let dr = -2; dr <= 2; dr++) {
                    for (let dc = -2; dc <= 2; dc++) {
                        const k = `${r + dr}-${c + dc}`;
                        if (wallCellToOwner.has(k)) {
                            const w = wallCellToOwner.get(k);
                            if (w && w.owner !== color) wallPenalty += 1;
                            else wallPenalty += 0.2;
                        }
                    }
                }

                // score: lower is better
                const score = len * 10 - Math.min(8, minOppDist) * 3 + wallPenalty * 6;
                if (score < bestScore) {
                    bestScore = score;
                    bestKey = key;
                }
            });

            // Fallback: any reachable target other than start
            if (!bestKey) {
                for (const key of reachableTargets) {
                    if (key !== bfsStartKey) {
                        bestKey = key;
                        break;
                    }
                }
            }

            return bestKey;
        }

        // Wall placement functions
        function toggleWallPlacement() {
            const color = turnOrder[currentTurn];
            if (botColors.has(color)) return;
            if (wallCounts[color] <= 0) return;
            if (!canPlaceWallThisTurn) return;

            if (!gameActive) {
                return; // Game is not active
            }

            if (!placingWall) {
                enterWallPlacementMode();
            } else {
                exitWallPlacementMode();
            }
        }

        function enterWallPlacementMode() {
            placingWall = true;
            document.querySelectorAll('.grid-item').forEach(el => {
                el.style.outline = '3px dashed rgba(255,255,255,0.5)';
            });
            placeWallBtn.textContent = 'Cancel Wall';
            placeWallBtnMobile.textContent = 'Cancel Wall';
        }

        function exitWallPlacementMode() {
            placingWall = false;
            document.querySelectorAll('.grid-item').forEach(el => {
                el.style.outline = '';
            });
            placeWallBtn.textContent = 'Place Wall';
            placeWallBtnMobile.textContent = 'Place Wall';
        }

        function placeWall(color, r, c) {
            if (!activeColors.includes(color)) return false;
            if (wallCounts[color] <= 0) return false;

            const key = `${r}-${c}`;
            if (!positionToElement[key]) return false;
            if (wallCellToOwner.has(key)) return false;

            // Prevent wall placement on cells with location icons (starting positions)
            const cell = positionToElement[key];
            if (cell && cell.querySelector('.location-icon')) return false;

            // Prevent placing a wall on a cell occupied by any goti
            // (don't block the exact cell where a token currently sits)
            for (const col of allColors) {
                const info = gotis[col];
                if (!info) continue;
                if (info.r === r && info.c === c) return false;
            }

            const ok = renderWallAt(r, c, color);
            if (!ok) return false;

            const remainingTurns = 3;
            walls[color].push({ r, c, remainingTurns });
            wallCellToOwner.set(key, { owner: color, remainingTurns });
            wallCounts[color] -= 1;

            updateWallsLeftUI();
            renderWallStacks();
            // persist state after placing a wall
            saveGameState();
            return true;
        }

        function renderWallAt(r, c, owner) {
            const key = `${r}-${c}`;
            const cell = positionToElement[key];
            if (!cell) return false;

            // Don't double place on same active wall
            if (wallCellToOwner.has(key)) return false;

            const overlay = document.createElement('div');
            overlay.className = 'wall-overlay';
            overlay.style.position = 'absolute';
            overlay.style.inset = '2px';

            const colorMap = {
                yellow: { bg: 'rgba(255,213,0,0.35)', border: '#ffd500' },
                green: { bg: 'rgba(104,221,0,0.35)', border: '#68DD00' },
                blue: { bg: 'rgba(51,112,255,0.35)', border: '#3370ff' },
                red: { bg: 'rgba(255,77,77,0.35)', border: '#ff4d4d' }
            };

            const cfg = colorMap[owner] || colorMap.red;
            overlay.style.background = cfg.bg;
            overlay.style.border = '3px solid ' + cfg.border;
            overlay.style.pointerEvents = 'none';
            cell.appendChild(overlay);

            // Play wall placement sound
            playWallSound();

            return true;
        }

        function removeWallAtKey(key) {
            wallCellToOwner.delete(key);
            const el = positionToElement[key];
            if (el) {
                const overlay = el.querySelector('.wall-overlay');
                if (overlay) el.removeChild(overlay);
            }
        }

        function tickWallsFor(ownerColor) {
            const arr = walls[ownerColor];
            if (!arr) return;

            for (let i = arr.length - 1; i >= 0; i--) {
                const w = arr[i];
                w.remainingTurns -= 1;
                const key = `${w.r}-${w.c}`;
                const entry = wallCellToOwner.get(key);
                if (entry && entry.owner === ownerColor) entry.remainingTurns = w.remainingTurns;

                if (w.remainingTurns <= 0) {
                    removeWallAtKey(key);
                    arr.splice(i, 1);
                }
            }
        }

        // UI update functions
        function updateWallsLeftUI() {
            const color = turnOrder[currentTurn] || 'yellow';
            const shown = wallCounts[color];
            wallsLeftEl.textContent = `Walls Left: ${shown}`;
            wallsLeftElMobile.textContent = `Walls Left: ${shown}`;
        }

        function updateRollButtonState() {
            const color = turnOrder[currentTurn];
            const isHumanTurn = color && !botColors.has(color);
            rollBtn.disabled = !isHumanTurn || !gameActive;
            rollBtn.style.opacity = isHumanTurn && gameActive ? '1' : '0.6';
            rollBtn.style.cursor = isHumanTurn && gameActive ? 'pointer' : 'not-allowed';

            rollBtnMobile.disabled = !isHumanTurn || !gameActive;
            rollBtnMobile.style.opacity = isHumanTurn && gameActive ? '1' : '0.6';
            rollBtnMobile.style.cursor = isHumanTurn && gameActive ? 'pointer' : 'not-allowed';

            // Update wall button state
            placeWallBtn.disabled = !isHumanTurn || !canPlaceWallThisTurn || wallCounts[color] <= 0 || !gameActive;
            placeWallBtnMobile.disabled = !isHumanTurn || !canPlaceWallThisTurn || wallCounts[color] <= 0 || !gameActive;

            // Tint roll and wall buttons to current player's color for clarity
            const colorMapBtn = {
                yellow: 'linear-gradient(135deg, #ffd500, #e6c200)',
                green: 'linear-gradient(135deg, #68DD00, #4db200)',
                blue: 'linear-gradient(135deg, #3370ff, #2158d8)',
                red: 'linear-gradient(135deg, #ff4d4d, #ff1f1f)'
            };
            const btnBg = colorMapBtn[color] || 'linear-gradient(135deg, #4CAF50, #45a049)';
            rollBtn.style.background = btnBg;
            placeWallBtn.style.background = btnBg;
            rollBtnMobile.style.background = btnBg;
            placeWallBtnMobile.style.background = btnBg;
        }

        function renderWallStacks() {
            const container = document.getElementById('wall-stacks');
            if (!container) return;

            container.innerHTML = '';
            const cfg = [
                { color: 'red', bg: '#ff4d4d' },
                { color: 'green', bg: '#68DD00' },
                { color: 'yellow', bg: '#ffd500' },
                { color: 'blue', bg: '#3370ff' }
            ];

            cfg.forEach(({ color, bg }) => {
                const col = document.createElement('div');
                col.className = 'wall-stack-column';

                for (let i = 0; i < 3; i++) {
                    const block = document.createElement('div');
                    block.className = 'wall-block';
                    block.style.background = (i < wallCounts[color]) ? bg : 'transparent';
                    col.appendChild(block);
                }

                container.appendChild(col);
            });
        }

        // Game state functions
        function nextTurn(skipIncrement) {
            if (!skipIncrement) currentTurn = (currentTurn + 1) % turnOrder.length;

            // Ensure currentTurn points to a non-completed color
            let guard = 0;
            while (completed[turnOrder[currentTurn]] && guard < 10) {
                currentTurn = (currentTurn + 1) % turnOrder.length;
                guard++;
            }

            turnSeq++;
            const color = turnOrder[currentTurn];

            // Decrement and expire walls for the current turn owner
            tickWallsFor(color);
            updateTurnDisplay();
            updateWallsLeftUI();
            updateRollButtonState();

            rollValue = 0;
            hasRolledThisTurn = false;
            canPlaceWallThisTurn = false;
            hasPlacedWallThisTurn = false;
            placeWallBtn.disabled = true;
            placeWallBtnMobile.disabled = true;
            placeWallBtn.textContent = 'Place Wall';
            placeWallBtnMobile.textContent = 'Place Wall';

            if (placingWall) exitWallPlacementMode();

            clearAllHighlights();

            // If it's a bot's turn, let it play automatically
            setTimeout(botTakeTurnIfNeeded, 500 / Math.max(1, botSpeedMultiplier));
            // persist state after turn advances
            saveGameState();
        }

        function showWin(color) {
            gameActive = false; // Stop the game temporarily
            completed[color] = true; // Mark this color as completed

            // Move winning goti to their wall stack position
            moveGotiToWallPosition(color);

            // Remove all walls belonging to the winning color
            removeAllWallsForColor(color);

            // Remove finished color from turn order so it no longer plays
            turnOrder = turnOrder.filter(c => !completed[c]);

            // Normalize currentTurn index if it is now out of range after removal
            if (turnOrder.length > 0) {
                currentTurn = currentTurn % turnOrder.length;
            }

            // Refresh layout to update visuals
            relayoutAllOccupants();

            // Record this color's finishing position
            finishOrder.push(color);

            // Count how many bots have finished
            let botsDone = 0;
            botColors.forEach(bc => { if (completed[bc]) botsDone++; });

            // ‚úÖ If all bots (3) have finished and human hasn't, user loses immediately
            if (botsDone === botColors.size && !completed[humanColor]) {
                playLoseSound();
                endGameWithMessage('You Lose! Read & Understand Rules.');
                return;
            }

            // Play win sound for whoever finished (bot or human)
            playWinSound();

            // If no turns are left, end the game safely
            if (!turnOrder.length) {
                endGameWithMessage('Game Over');
                return;
            }

            // ‚úÖ If human finished, determine rank
            if (color === humanColor) {
                const rank = finishOrder.indexOf(humanColor) + 1;
                if (rank === 1) {
                    playWinSound();
                    endGameWithMessage('You Win! You Got 1st Position');
                } else if (rank === 2) {
                    endGameWithMessage('You Got 2nd Position, Better Luck Next Time!');
                } else if (rank === 3) {
                    endGameWithMessage('You Got 3rd Position, Try Again!');
                }
                // Stop here since human has finished
                return;
            }

            // ‚úÖ If game still has players left, continue normally
            gameActive = true;
            updateRollButtonState();
            nextTurn(true);
        }

        function endGameWithMessage(message) {
            gameActive = false; // Stop the game
            winText.textContent = message;
            winOverlay.style.display = 'flex';
        }

        function resetGame() {
            window.location.href = "index.html"; // Redirects to index.html
        }

        // Sound functions
        function playDiceSound() {
            if (!soundEnabled) return;
            if (diceSound) {
                diceSound.currentTime = 0;
                diceSound.play().catch(e => console.log("Audio play failed:", e));
            }
        }

        function playGotiMoveSound() {
            if (!soundEnabled) return;
            if (gotiMoveSound) {
                gotiMoveSound.currentTime = 0;
                gotiMoveSound.play().catch(e => console.log("Audio play failed:", e));
            }
        }

        function stopGotiMoveSound() {
            if (gotiMoveSound) {
                try {
                    gotiMoveSound.pause();
                    gotiMoveSound.currentTime = 0;
                } catch (e) {
                    // ignore errors when stopping audio
                }
            }
        }

        function playWallSound() {
            if (!soundEnabled) return;
            if (wallSound) {
                wallSound.currentTime = 0;
                wallSound.play().catch(e => console.log("Wall sound play failed:", e));
            }
        }

        function playWinSound() {
            if (!soundEnabled) return;
            if (winSound) {
                try {
                    winSound.currentTime = 0;
                    winSound.play().catch(e => console.log('Win sound play failed:', e));
                } catch (e) {
                    // ignore
                }
            }
        }

        function playLoseSound() {
            if (!soundEnabled) return;
            if (loseSound) {
                try {
                    loseSound.currentTime = 0;
                    loseSound.play().catch(e => console.log('Lose sound play failed:', e));
                } catch (e) {
                    // ignore
                }
            }
        }

        function stopAllSounds() {
            try {
                if (diceSound) {
                    diceSound.pause();
                    diceSound.currentTime = 0;
                }
                if (gotiMoveSound) {
                    gotiMoveSound.pause();
                    gotiMoveSound.currentTime = 0;
                }
                if (wallSound) {
                    wallSound.pause();
                    wallSound.currentTime = 0;
                }
                if (winSound) {
                    winSound.pause();
                    winSound.currentTime = 0;
                }
                if (loseSound) {
                    loseSound.pause();
                    loseSound.currentTime = 0;
                }
            } catch (e) {
                // ignore any errors stopping audio
            }
        }

        // Settings functions
        function openSettings() {
            settingsModal.style.display = 'flex';
        }

        function closeSettings() {
            settingsModal.style.display = 'none';
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('active', soundEnabled);

            // Save setting to localStorage
            localStorage.setItem('deceptionist_sound_enabled', soundEnabled.toString());
            // If sound was just disabled, stop any currently playing audio
            if (!soundEnabled) {
                stopAllSounds();
            }
        }

        function loadSoundSetting() {
            const savedSoundSetting = localStorage.getItem('deceptionist_sound_enabled');
            if (savedSoundSetting !== null) {
                soundEnabled = savedSoundSetting === 'true';
                soundToggle.classList.toggle('active', soundEnabled);
                if (!soundEnabled) stopAllSounds();
            }
        }

        // Utility functions
        function neighborsOf(r, c) {
            const deltas = [[1, 0], [-1, 0], [0, 1], [0, -1]];
            const result = [];
            for (const [dr, dc] of deltas) {
                const nr = r + dr;
                const nc = c + dc;
                const key = `${nr}-${nc}`;
                if (positionToElement[key]) result.push([nr, nc]);
            }
            return result;
        }

        function computePath(start, goal) {
            const startKey = `${start[0]}-${start[1]}`;
            const goalKey = `${goal[0]}-${goal[1]}`;
            const queue = [start];
            const visited = new Set([startKey]);
            const parent = new Map();

            while (queue.length) {
                const [r, c] = queue.shift();
                const key = `${r}-${c}`;
                if (key === goalKey) break;

                for (const [nr, nc] of neighborsOf(r, c)) {
                    const nkey = `${nr}-${nc}`;
                    if (!visited.has(nkey)) {
                        visited.add(nkey);
                        parent.set(nkey, key);
                        queue.push([nr, nc]);
                    }
                }
            }

            // Reconstruct path
            if (!parent.size && startKey !== goalKey) return [start];
            const path = [];
            let cur = goalKey;
            path.push([goal[0], goal[1]]);

            while (cur !== startKey) {
                const prev = parent.get(cur);
                if (!prev) break; // fallback if unreachable
                const [pr, pc] = prev.split('-').map(Number);
                path.push([pr, pc]);
                cur = prev;
            }

            path.push([start[0], start[1]]);
            path.reverse();
            return path;
        }

        function canEnterCell(color, r, c) {
            const key = `${r}-${c}`;
            const entry = wallCellToOwner.get(key);
            if (!entry) return true;
            return entry.owner === color; // only owner can enter
        }

        function bfsReachableExact(startR, startC, steps, moverColor) {
            const startKey = `${startR}-${startC}`;
            const queue = [[startR, startC, 0]];
            const visited = new Set([startKey]);
            const parents = new Map();
            const targets = new Set();

            while (queue.length) {
                const [r, c, d] = queue.shift();
                if (d === steps) {
                    targets.add(`${r}-${c}`);
                    continue;
                }

                for (const [nr, nc] of neighborsOf(r, c)) {
                    if (!canEnterCell(moverColor, nr, nc)) continue;
                    const key = `${nr}-${nc}`;
                    if (!visited.has(key)) {
                        visited.add(key);
                        parents.set(key, `${r}-${c}`);
                        queue.push([nr, nc, d + 1]);
                    }
                }
            }

            return { targets, parents, startKey };
        }

        function clearAllHighlights() {
            if (reachableTargets.size) {
                reachableTargets.forEach(key => {
                    const el = positionToElement[key];
                    if (el) {
                        el.classList.remove('highlighted-forward');
                        el.classList.remove('highlighted-backward');
                        // Restore original background and border
                        const baseBg = el.dataset.baseBg || '';
                        el.style.background = baseBg;
                        el.style.border = el.dataset.baseBorder || '2px solid black';
                    }
                });
            }

            reachableTargets = new Set();
            bfsParents = new Map();
            bfsStartKey = '';

            if (forwardHighlighted) {
                forwardHighlighted.classList.remove('highlighted-forward');
                forwardHighlighted = null;
            }

            if (backwardHighlighted) {
                backwardHighlighted.classList.remove('highlighted-backward');
                backwardHighlighted = null;
            }
        }

        function colorTint(color) {
            if (color === 'yellow') return { bg: 'rgba(255,255,0,0.35)', border: '3px solid #b3b300' };
            if (color === 'green') return { bg: 'rgba(104,221,0,0.35)', border: '3px solid #3a8f00' };
            if (color === 'blue') return { bg: 'rgba(0,0,255,0.35)', border: '3px solid #001a99' };
            return { bg: 'rgba(255,0,0,0.35)', border: '3px solid #990000' };
        }

        function isAtGoal(color) {
            const goals = { yellow: centerRed, red: centerYellow, green: centerBlue, blue: centerGreen };
            const [gr, gc] = goals[color];
            const g = gotis[color];
            return g.r === gr && g.c === gc;
        }

        function placeGotiAtCell(color, r, c) {
            const gotiData = gotis[color];
            const cellWidthPct = 100 / cols;
            const cellHeightPct = 100 / rows;
            const sizePct = Math.min(cellWidthPct, cellHeightPct) * 0.7;

            gotiData.goti.style.width = sizePct + '%';
            gotiData.goti.style.height = sizePct + '%';
            gotiData.goti.style.left = (c * cellWidthPct + cellWidthPct / 2) + '%';
            gotiData.goti.style.top = (r * cellHeightPct + cellHeightPct / 2) + '%';
            gotiData.r = r;
            gotiData.c = c;

            relayoutAllOccupants();
        }

        function placeGotiAtHome(color) {
            const goti = gotis[color].goti;
            const cellW = 100 / cols;
            const cellH = 100 / rows;
            const sizePct = Math.min(cellW, cellH) * 0.7;

            goti.style.width = sizePct + '%';
            goti.style.height = sizePct + '%';

            // Force layout to update
            void goti.offsetWidth;

            const starts = { yellow: startYellow, green: startGreen, blue: startBlue, red: startRed };
            const [sr, sc] = starts[color];

            // Position token visually above its color's wall stack (renderWallStacks order: red, green, yellow, blue)
            const order = { red: 0, green: 1, yellow: 2, blue: 3 };
            const wallStacks = document.getElementById('wall-stacks');
            if (wallStacks && wallStacks.children[order[color]]) {
                const column = wallStacks.children[order[color]];
                const topBlock = column.children[0] || column;
                const colRect = column.getBoundingClientRect();
                const topRect = topBlock.getBoundingClientRect();
                const boardRect = document.querySelector('.outer-box').getBoundingClientRect();
                const xAbs = colRect.left + colRect.width / 2;
                const yAbs = topRect.top - (goti.getBoundingClientRect().height / 2) - 8;
                const x = ((xAbs - boardRect.left) / boardRect.width) * 100;
                const y = ((yAbs - boardRect.top) / boardRect.height) * 100;
                goti.style.left = Math.min(96, Math.max(2, x)) + '%';
                goti.style.top = Math.min(96, Math.max(2, y)) + '%';
            } else {
                // Fallback: center at its start cell edge
                goti.style.left = (sc * cellW + cellW / 2) + '%';
                goti.style.top = (sr * cellH + cellH / 2) + '%';
            }

            gotis[color].r = sr;
            gotis[color].c = sc;
        }

        function updateAllGotiSizes() {
            const cellW = 100 / cols;
            const cellH = 100 / rows;
            const sizePct = Math.min(cellW, cellH) * 0.7;

            allColors.forEach(color => {
                const g = gotis[color]?.goti;
                if (g) {
                    g.style.width = sizePct + '%';
                    g.style.height = sizePct + '%';

                    if (isUnlocked[color]) {
                        // For unlocked tokens, center on their current grid cell
                        const r = gotis[color].r;
                        const c = gotis[color].c;
                        g.style.left = (c * cellW + cellW / 2) + '%';
                        g.style.top = (r * cellH + cellH / 2) + '%';
                    } else {
                        // For locked tokens, keep them just outside their home edge
                        placeGotiAtHome(color);
                    }
                }
            });

            // Re-apply stacked layout after resizing
            relayoutAllOccupants();
        }

        function relayoutAllOccupants() {
            const cellW = 100 / cols;
            const cellH = 100 / rows;
            const normalSize = Math.min(cellW, cellH) * 0.7;
            // Make stacked tokens smaller so there's more room, and increase offsets for clearer separation
            const smallSize = Math.min(cellW, cellH) * 0.38;
            const byCell = new Map();

            allColors.forEach(color => {
                if (!isUnlocked[color]) return;
                const info = gotis[color];
                const key = `${info.r}-${info.c}`;
                if (!byCell.has(key)) byCell.set(key, []);
                byCell.get(key).push(color);
            });

            // First reset all to normal center, then adjust stacked
            allColors.forEach(color => {
                if (!isUnlocked[color]) return;
                const info = gotis[color];
                const g = info.goti;
                g.style.width = normalSize + '%';
                g.style.height = normalSize + '%';
                g.style.left = (info.c * cellW + cellW / 2) + '%';
                g.style.top = (info.r * cellH + cellH / 2) + '%';
            });

            byCell.forEach((colors, key) => {
                if (colors.length <= 1) return;
                const [r, c] = key.split('-').map(Number);

                // Define offset patterns inside a cell for up to 4 tokens
                let offsets;
                if (colors.length === 2) {
                    offsets = [[-0.28, -0.28], [0.28, 0.28]];
                } else if (colors.length === 3) {
                    offsets = [[-0.32, -0.24], [0.32, -0.24], [0.0, 0.32]];
                } else {
                    // 4 or more: use 2x2 grid with larger separation; extras overlap last positions
                    offsets = [[-0.32, -0.32], [0.32, -0.32], [-0.32, 0.32], [0.32, 0.32]];
                }

                colors.forEach((color, idx) => {
                    const info = gotis[color];
                    const g = info.goti;
                    const off = offsets[Math.min(idx, offsets.length - 1)];
                    g.style.width = smallSize + '%';
                    g.style.height = smallSize + '%';
                    g.style.left = (c * cellW + cellW / 2 + off[0] * cellW) + '%';
                    g.style.top = (r * cellH + cellH / 2 + off[1] * cellH) + '%';
                });
            });
        }

        function moveGotiToWallPosition(color) {
            isUnlocked[color] = false;
            completed[color] = true;
            // Reuse placeGotiAtHome calculation to position above wall stack
            placeGotiAtHome(color);
        }

        function removeAllWallsForColor(color) {
            walls[color] = [];

            // Remove all wall entries from wallCellToOwner for this color
            const keysToRemove = [];
            wallCellToOwner.forEach((entry, key) => {
                if (entry.owner === color) {
                    keysToRemove.push(key);
                }
            });

            keysToRemove.forEach(key => {
                removeWallAtKey(key);
            });

            // Reset wall count for this color
            wallCounts[color] = 0;

            // Update UI
            updateWallsLeftUI();
            renderWallStacks();
        }

        // Persist / restore state so refresh doesn't reset the game
        function saveGameState() {
            try {
                const state = {
                    currentTurn,
                    turnOrder,
                    currentPositions,
                    isUnlocked,
                    wallCounts,
                    walls,
                    wallCellToOwner: Array.from(wallCellToOwner.entries()),
                    completed,
                    finishOrder,
                    humanColor
                };
                localStorage.setItem('deceptionist_game_state', JSON.stringify(state));
            } catch (e) {
                console.warn('Failed to save game state', e);
            }
        }

        function loadGameState() {
            try {
                const raw = localStorage.getItem('deceptionist_game_state');
                if (!raw) return;
                const state = JSON.parse(raw);
                if (!state) return;

                // restore simple scalars
                if (state.turnOrder) turnOrder = state.turnOrder;
                if (typeof state.currentTurn === 'number') currentTurn = state.currentTurn;
                if (state.wallCounts) Object.assign(wallCounts, state.wallCounts);
                if (state.isUnlocked) Object.assign(isUnlocked, state.isUnlocked);
                if (state.completed) Object.assign(completed, state.completed);
                if (Array.isArray(state.finishOrder)) finishOrder = state.finishOrder;
                if (state.humanColor) humanColor = state.humanColor;

                // restore walls
                if (state.wallCellToOwner) {
                    wallCellToOwner.clear();
                    state.wallCellToOwner.forEach(([k, v]) => wallCellToOwner.set(k, v));
                }

                // restore positions
                if (state.currentPositions) {
                    Object.keys(state.currentPositions).forEach(color => {
                        if (gotis[color]) {
                            const p = state.currentPositions[color];
                            gotis[color].r = p.r ?? gotis[color].r;
                            gotis[color].c = p.c ?? gotis[color].c;
                            if (isUnlocked[color]) {
                                placeGotiAtCell(color, gotis[color].r, gotis[color].c);
                            } else {
                                placeGotiAtHome(color);
                            }
                        }
                    });
                }

                // Update UI elements
                const youColorEl = document.getElementById('you-color');
                const youColorElMobile = document.getElementById('you-color-mobile');
                if (youColorEl) youColorEl.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
                if (youColorElMobile) youColorElMobile.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);

                // Re-render walls
                wallCellToOwner.forEach((entry, key) => {
                    const [r, c] = key.split('-').map(Number);
                    renderWallAt(r, c, entry.owner);
                });

                renderWallStacks();
                updateWallsLeftUI();
                updateRollButtonState();
                updateTurnDisplay();

                // Hide color selection if game is already in progress
                if (state.turnOrder && state.turnOrder.length > 0) {
                    colorSelection.style.display = 'none';
                    applyMode(currentMode);
                    updateAllGotiSizes();
                }
            } catch (e) {
                console.warn('Failed to load game state', e);
            }
        }

        function showDice(num, callback) {
            const dice = document.getElementById('dice');
            const diceMobile = document.getElementById('dice-mobile');
            const diceResult = document.getElementById('dice-result');
            const diceResultMobile = document.getElementById('dice-result-mobile');
            if (!dice || !diceMobile) return;

            // Show number immediately
            diceResult.textContent = `Rolled: ${num}`;
            diceResultMobile.textContent = `Rolled: ${num}`;

            // rotation mapping
            const rotations = {
                1: { x: 0, y: 0 },
                2: { x: 90, y: 0 },
                3: { x: 0, y: -90 },
                4: { x: 0, y: 90 },
                5: { x: -90, y: 0 },
                6: { x: 180, y: 0 }
            };

            const { x, y } = rotations[num];
            const extraX = 360 * (Math.floor(Math.random() * 3) + 2);
            const extraY = 360 * (Math.floor(Math.random() * 3) + 2);
            const extraZ = 360 * (Math.floor(Math.random() * 3) + 2);

            // Apply rotation to both dice
            dice.style.transform = `rotateX(${x + extraX}deg) rotateY(${y + extraY}deg) rotateZ(${extraZ}deg)`;
            diceMobile.style.transform = `rotateX(${x + extraX}deg) rotateY(${y + extraY}deg) rotateZ(${extraZ}deg)`;

            // Wait for animation to complete, then call callback. Use a fallback timeout to avoid hanging
            if (callback) {
                let called = false;
                const handleTransitionEnd = () => {
                    if (called) return;
                    called = true;
                    dice.removeEventListener('transitionend', handleTransitionEnd);
                    diceMobile.removeEventListener('transitionend', handleTransitionEnd);
                    clearTimeout(fallback);
                    callback();
                };
                const fallback = setTimeout(() => {
                    if (called) return;
                    called = true;
                    dice.removeEventListener('transitionend', handleTransitionEnd);
                    diceMobile.removeEventListener('transitionend', handleTransitionEnd);
                    callback();
                }, 2000);
                dice.addEventListener('transitionend', handleTransitionEnd);
                diceMobile.addEventListener('transitionend', handleTransitionEnd);
            }
        }

        // Initialize the game
        window.addEventListener('load', () => {
            initGame();
            // Auto-select yellow by default
            colorOptions[0].classList.add('selected');
            const youColorEl = document.getElementById('you-color');
            const youColorElMobile = document.getElementById('you-color-mobile');
            if (youColorEl) youColorEl.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
            if (youColorElMobile) youColorElMobile.textContent = humanColor.charAt(0).toUpperCase() + humanColor.slice(1);
        });

        window.addEventListener('resize', () => {
            updateAllGotiSizes();
            renderWallStacks();
            renderEntryArrows();
        });

        // Create animated arrows outside entry points
        // Create animated arrows outside entry points
        function renderEntryArrows() {
            // remove existing
            document.querySelectorAll('.entry-arrow').forEach(e => e.remove());
            const outer = document.querySelector('.outer-box');
            if (!outer) return;

            const map = [
                { entry: '0-8', owner: 'yellow', arrowColor: 'red', dir: 'up' },
                { entry: '13-8', owner: 'red', arrowColor: 'yellow', dir: 'down' },
                { entry: '7-0', owner: '#68DD00', arrowColor: 'blue', dir: 'left' },
                { entry: '7-16', owner: 'blue', arrowColor: '#68DD00', dir: 'right' }
            ];

            map.forEach(cfg => {
                const el = positionToElement[cfg.entry];
                if (!el) return;
                const arrow = document.createElement('div');
                arrow.className = 'entry-arrow';
                arrow.style.background = 'transparent';

                let svg = '';
                const fill = cfg.arrowColor;
                const isMobile = window.innerWidth <= 480;
                const arrowSize = isMobile ? 20 : 36;
                const marginU = 19;
                const marginB = 16;
                const marginR = 14;
                const marginL = 18;
                const rightMargin = -2;

                if (cfg.dir === 'up') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M12 2 L20 14 H4 L12 2 Z"/></svg>`;
                } else if (cfg.dir === 'down') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M12 22 L4 10 H20 L12 22 Z"/></svg>`;
                } else if (cfg.dir === 'left') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M2 12 L14 4 V20 L2 12 Z"/></svg>`;
                } else if (cfg.dir === 'right') {
                    svg = `<svg viewBox="0 0 24 24" fill="${fill}" xmlns="http://www.w3.org/2000/svg"><path d="M22 12 L10 20 V4 L22 12 Z"/></svg>`;
                }

                arrow.innerHTML = svg;

                if (isMobile) {
                    // place arrow inside the entry cell, near the cell edge
                    arrow.style.position = 'absolute';
                    arrow.style.width = arrowSize + 'px';
                    arrow.style.height = arrowSize + 'px';
                    arrow.style.animation = 'none';
                    if (cfg.dir === 'up') {
                        arrow.style.left = '50%';
                        arrow.style.top = '-15px';
                        arrow.style.transform = 'translateX(-50%)';
                    } else if (cfg.dir === 'down') {
                        arrow.style.left = '50%';
                        arrow.style.bottom = '-15px';
                        arrow.style.transform = 'translateX(-50%)';
                    } else if (cfg.dir === 'left') {
                        arrow.style.left = '-15px';
                        arrow.style.top = '50%';
                        arrow.style.transform = 'translateY(-50%)';
                    } else if (cfg.dir === 'right') {
                        arrow.style.right = '-15px';
                        arrow.style.top = '50%';
                        arrow.style.transform = 'translateY(-50%)';
                    }
                    el.style.position = 'relative';
                    el.appendChild(arrow);
                } else {
                    // original behavior: float outside board
                    const outerRect = outer.getBoundingClientRect();
                    const boardRect = outerRect; // alias
                    arrow.style.position = 'absolute';
                    arrow.style.width = arrowSize + 'px';
                    arrow.style.height = arrowSize + 'px';
                    if (cfg.dir === 'up') {
                        arrow.style.left = '48%';
                        arrow.style.top = (-marginU) + 'px';
                        arrow.style.transform = `translateX(calc(-50% + ${rightMargin}px))`;
                    } else if (cfg.dir === 'down') {
                        arrow.style.left = '48%';
                        arrow.style.top = (boardRect.height - arrowSize + marginB) + 'px';
                        arrow.style.transform = `translateX(calc(-50% + ${rightMargin}px))`;
                    } else if (cfg.dir === 'left') {
                        arrow.style.left = (-marginL + rightMargin) + 'px';
                        arrow.style.top = '51%';
                        arrow.style.transform = 'translateY(-50%)';
                    } else if (cfg.dir === 'right') {
                        arrow.style.left = (boardRect.width - arrowSize + marginR + rightMargin) + 'px';
                        arrow.style.top = '51%';
                        arrow.style.transform = 'translateY(-50%)';
                    }
                    outer.appendChild(arrow);
                }
            });
        }
    </script>
</body>

</html>